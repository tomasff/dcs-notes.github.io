<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="../assets/js/tocNav.js"></script>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Graph Related Pseudocode | Computer Science Revision Guides</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Graph Related Pseudocode" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Depth First Search (DFS) DFS for a particular node:" />
<meta property="og:description" content="Depth First Search (DFS) DFS for a particular node:" />
<link rel="canonical" href="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/pseudoCodes.html" />
<meta property="og:url" content="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/pseudoCodes.html" />
<meta property="og:site_name" content="Computer Science Revision Guides" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-12T14:53:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Graph Related Pseudocode" />
<script type="application/ld+json">
{"description":"Depth First Search (DFS) DFS for a particular node:","headline":"Graph Related Pseudocode","dateModified":"2021-05-12T14:53:39+00:00","datePublished":"2021-05-12T14:53:39+00:00","url":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/pseudoCodes.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/pseudoCodes.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/pages/CSRG-Group/dcs-notes.github.io/assets/css/style.css?v=c7cba74afde9610b1e7114060896a196d092ead3">
</head>

<body>
    <header style="padding:10px;" class="page-header" role="banner">
        <h1 class="project-name">Graph Related Pseudocode</h1>
    </header>
    <div id="mainGrid" class="container">
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#depth-first-search-dfs">Depth First Search (DFS)</a><ul><li><a href="#dfs-for-a-particular-node-">DFS for a particular node: </a></li><li><a href="#dfs-for-an-entire-graph">DFS for an entire graph:</a></li><li><a href="#path-finding-with-dfs">Path Finding with DFS</a></li><li><a href="#cycle-finding-with-dfs">Cycle Finding with DFS</a></li></ul></li><li><a href="#breadth-first-search-bfs-pseudocode">Breadth First Search (BFS) Pseudocode</a><ul><li><a href="#directed-graphs">Directed graphs</a><ul><li><a href="#topological-ordering-using-dfs">Topological ordering using DFS</a></li></ul></li></ul></li></ul>
</div>
        </div>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS126/part9.html" title="">👈Prev</a><a href="./" title="CS126 Home">🏡CS126</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h1 id="depth-first-search-dfs">Depth First Search (DFS)</h1>
<h2 id="dfs-for-a-particular-node-">DFS for a particular node: <br /></h2>

<p>The following algorithm is pseudocode for Depth First Search - as displayed by the CS126 lectures</p>

<p><strong>Algorithm</strong> $DFS(G, v)$ <br />
     <strong>Input</strong>  graph $G$ and start at vertex $v$ of $G$<br />
     <strong>Output</strong> labeling of the edges of $G$ in the connected component of v as discovery edges and back edges 
<br />
<br />
     
$setLabel(v, VISITED)$ <br />
     
<strong>for all</strong> $e \in G.incidentEdges(v)$ <br />
         
<strong>if</strong> $getLabel(e) = UNEXPLORED$ <br />
            
$w \leftarrow opposite(v,e)$ <br />
            
<strong>if</strong> $getLabel(w) = UNEXPLORED$ <br />
                
$setLabel(e, DISCOVERY)$ <br />
                
$DFS(G, w)$ <br />
            
<strong>else</strong> <br />
                
$setLabel(e,BACK)$ <br /></p>

<p><strong>END ALGORITHM</strong></p>

<p><br />
<br /><br /></p>

<h2 id="dfs-for-an-entire-graph">DFS for an entire graph:</h2>
<p>The following algorithm is pseudocode for Depth First Search - as displayed by the CS126 lectures, which is used to perform depth first search on the entire graph.</p>

<p><strong>Algorithm</strong> $DFS(G)$ <br />
     <strong>Input</strong>  graph $G$ <br />
     <strong>Output</strong> labelling of the edges of $G$ as discovery and back edges
<br />
<br />
     <strong>for all</strong> $u \in G.vertices()$ <br />
         <strong>$setLabel(u, UNEXPLORED)$</strong> <br /></p>

<p>     <strong>for all</strong> $e \in G.edges()$ <br />
         <strong>$setLabel(e, UNEXPLORED)$</strong> <br /></p>

<p>     <strong>for all</strong> $u \in G.vertices()$ <br />
         <strong>if $getLabel(u, UNEXPLORED)$</strong> <br />
             $DFS(G, v)$ <br /></p>

<p><strong>END ALGORITHM</strong>
<br /></p>

<p><strong>Algorithm</strong> $DFS(G, v)$ <br />
     <strong>Input</strong>  graph $G$ and start at vertex $v$ of $G$<br />
     <strong>Output</strong> labeling of the edges of $G$ in the connected component of v as discovery edges and back edges 
<br />
<br />
     
$setLabel(v, VISITED)$ <br />
     
<strong>for all</strong> $e \in G.incidentEdges(v)$ <br />
         
<strong>if</strong> $getLabel(e) = UNEXPLORED$ <br />
            
$w \leftarrow opposite(v,e)$ <br />
            
<strong>if</strong> $getLabel(w) = UNEXPLORED$ <br />
                
$setLabel(e, DISCOVERY)$ <br />
                
$DFS(G, w)$ <br />
            
<strong>else</strong> <br />
                
$setLabel(e,BACK)$ <br /></p>

<p><strong>END ALGORITHM</strong>
<br /><br /><br /></p>

<h2 id="path-finding-with-dfs">Path Finding with DFS</h2>
<p>By using an alteration of the depth first search algorithm, we can use it to find a path between two given vertices, using the <strong>template method pattern</strong></p>

<p><strong>Algorithm</strong>
$pathDFS(G,v,z)$ <br />
    
$setLabel(v, VISITED)$ <br />
    
$S.push(v)$<br />
    
<strong>if</strong> $v=z$<br />
        
<strong>return</strong> $S.elements()$ <br />
    
<strong>for all</strong> $e \in G.incidentEdges(v)$<br />
        
<strong>if</strong> $getLabel(e) = UNEXPLORED$ <br />
            
$w \leftarrow opposite(v,e)$ <br />
            
<strong>if</strong> $getLabel(w) = UNEXPLORED$ <br />
                
$setLabel(e,DISCORVERY)$ <br />
                
$S.push(e)$<br />
                
$pathDFS(G,w,z)$<br />
                
$S.pop(e)$<br />
            
<strong>else</strong><br />
                
$setLabel(e, BACK)$<br />
        
$S.pop(v)$<br /></p>

<p><strong>END ALGORITHM</strong></p>

<p><br /><br /><br /></p>

<h2 id="cycle-finding-with-dfs">Cycle Finding with DFS</h2>

<p><strong>Algorithm</strong> $cycleDFS(G,v)$<br />
    
$setLabel(v,VISITED)$ <br />
    
$S.push(v)$ <br />
    
<strong>for all</strong> $e \in G.incidentEdges(v)$<br />
        
<strong>if</strong> $getLabel(e) = UNEXPLORED$<br />
            
$w \leftarrow opposite(v,e)$<br />
            
$S.push(e)$ <br />
            
<strong>if</strong> $getLabel(w)= UNEXPLORED$ <br />
                
<strong>if</strong> $setLabel(e,DISCOVERY)$ <br />
                
$cycleDFS(G,w)$ <br />
                
$S.pop(e)$<br />
            
<strong>else</strong> <br />
                
<strong>T</strong> $\leftarrow$ new empty stack <br />
                
<strong>repeat</strong><br />
                    
$o \leftarrow S.pop()$ <br />
                    
$T.push(o)$ <br />
                
<strong>until</strong> $o=w$<br />
                
<strong>return</strong> $T.elements()$ <br />
    
$S.pop(v)$<br /></p>

<p><strong>END ALGORITHM</strong></p>

<p><br /><br /><br /></p>

<h1 id="breadth-first-search-bfs-pseudocode">Breadth First Search (BFS) Pseudocode</h1>
<p>This algorithm is a graph traversal algorithm which follows the general directive: <br /></p>

<ol>
  <li>First visit all vertices that are a distance of 1 from then starting node.</li>
  <li>Second, visit all vertices of distance 2, up until all vertices have been visited.</li>
</ol>

<p>The result of this, is that each time an edge is reached, it is one (possibly of many) of the shortest paths to that particular node.</p>

<p><strong>Algorithm</strong> $BFS(G)$ <br />
     
<strong>Input</strong> graph $G$ <br />
    
<strong>Output</strong> labeling of the edges and partition of the vertices of G<br />
    
<strong>for all</strong> $e \in G.vertices()$ <br />
        
$setLabel(u, UNEXPLORED)$ <br />
    
<strong>for all</strong> $e \in G.edges()$ <br />
        
$setLabel(e, UNEXPLORED)$ <br />
    
<strong>for all</strong> $v \in G.vertices()$<br />
        
<strong>if</strong> $getLabel(v) = UNEXPLORED$ <br />
            
$BFS(G,v)$
<br /></p>

<p><strong>END ALGORITHM</strong>
<br /><br /><br />
<strong>Algorithm</strong> $BFS(G, s)$ <br />
    
$L_0 \leftarrow$ new empty sequence <br />
    
$L_0 .addLast(s)$  <br />
    
$setLabel(s, VISITED)$ <br />
    
$i \leftarrow 0$ <br />
    
<strong>while</strong> $¬L_i .isEmpty()$ <br />
        
$L_i+1 \leftarrow$ new empty sequence <br />
        
<strong>for all</strong> $v\in L_i .elements()$ <br />
            
<strong>for all</strong> $e \in G.incidentEdges(v)$ <br />
                
<strong>if</strong> $getLabel(e) = UNEXPLORED$ <br />
                    
$w \leftarrow opposite(v,e)$ <br />
                    
<strong>if</strong> $getLabel(w) = UNEXPLORED$ <br />
                        
$setLabel(e) = (e, DISCOVERY)$ <br />
                        
$setLabel(w,VISITED)$ <br />
                        
$L_i+1 .addLast(w)$ <br />
                    
<strong>else</strong> <br />
                        
$setLabel(e,CROSS)$ <br />
        
$i \leftarrow i + 1$
<br /></p>

<p><strong>END ALGORITHM</strong></p>

<h2 id="directed-graphs">Directed graphs</h2>

<ul>
  <li>This algorithm is the Floyd Warshall algorithm, which is used to compute the transitive closure on a directed graph.</li>
</ul>

<p><strong>Algorithm</strong> $FloydWarshall(G)$ <br />
    
<strong>Input</strong> digraph $G$ <br />
    
<strong>Output</strong> transitive closure $G^*$ of $G$ <br /><br />
    
$i \leftarrow 1$ <br />
    
<strong>for all</strong> $v \in G.vertices()$ <br />
        
denote $v$ as $v_i$ <br />
        
$i \leftarrow i + 1$ <br />
    
$G_0 \leftarrow G$ <br />
    
<strong>for</strong> $k \leftarrow 1$ <strong>to</strong> $n$ <strong>do</strong><br />
        
$G_k \leftarrow G_{k-1}$ <br />
            
<strong>for</strong> $i\leftarrow 1$ <strong>to</strong> $n(i\neq k)$ <strong>do</strong> <br />
                
<strong>for</strong> $j \leftarrow 1$ <strong>to</strong> $n(j\neq i, k)$ <strong>do</strong> <br />
                    
<strong>if</strong> $G_{k-1}.areAdjacent(v_i,v_k)$  $\&amp;$ $G_{k-1}.areAdjacent(v_k,v_j)$ <br />
                        
<strong>if</strong> $¬G_{k-1}.areAdjacent(v_i,v_j)$ <br />
                            
$G_k.insertDirectedEdge(v_i,v_j,k)$<br />
        
<strong>return</strong> $G_n$
<br /><br /><br /></p>

<h3 id="topological-ordering-using-dfs">Topological ordering using DFS</h3>

<p><strong>Algorithm</strong> $topologicalDFS(G)$ <br />
    
<strong>Input</strong> dag $G$<br />
    
<strong>Output</strong> topotlogical ordering of G <br /><br />
    
$n \leftarrow G.numVertices()$ <br />
    
<strong>for all</strong> $u\in G.vertices()$ <br />
        
$setLabel(,UNEXPLORED)$ <br />
    
<strong>for all</strong> $v\in G.vertices()$ <br />
        
<strong>if</strong> $getLabel(v) = UNEXPLORED$ <br />
            
$topologicalDFS(G,v)$
<br /><br /><br />
<strong>Algorithm</strong> $topologicalDFS(G,v)$ <br />
    
<strong>Input</strong> graph $G$ and start a vertex $v$ of $G$ <br />
    
<strong>Output</strong> labeling of the vertices of G in the connected component of $v$ <br /><br />
    
$setLabel(v, VISITED)$ <br />
    
<strong>for all</strong> $e\in G.outEdges(v)$  <br />
        
$w\in opposite(v,e)$ // Outgoing edges <br />
        
<strong>if</strong> $getLabel(w) = UNEXPLORED$  <br />
            
$topologicalDFS(G,w)$ // $e$ is a discovery edge<br />
        
<strong>else</strong> <br />
            
Label $v$ with topological number $n$ // $e$ is a forward or cross edge<br />
        
$n\leftarrow n - 1$ <br /></p>



                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub
                            Pages</a>.</span>
                </footer>
            </main>
        </div>
    </div>
</body>

</html>