<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="../assets/js/tocNav.js"></script>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Skip lists | Computer Science Revision Guides</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Skip lists" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Goals for skip lists" />
<meta property="og:description" content="Goals for skip lists" />
<link rel="canonical" href="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/part9.html" />
<meta property="og:url" content="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/part9.html" />
<meta property="og:site_name" content="Computer Science Revision Guides" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-12T14:53:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Skip lists" />
<script type="application/ld+json">
{"description":"Goals for skip lists","headline":"Skip lists","dateModified":"2021-05-12T14:53:39+00:00","datePublished":"2021-05-12T14:53:39+00:00","url":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/part9.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS126/part9.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/pages/CSRG-Group/dcs-notes.github.io/assets/css/style.css?v=c7cba74afde9610b1e7114060896a196d092ead3">
</head>

<body>
    <header style="padding:10px;" class="page-header" role="banner">
        <h1 class="project-name">Skip lists</h1>
    </header>
    <div id="mainGrid" class="container">
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#goals-for-skip-lists">Goals for skip lists</a></li><li><a href="#skip-lists-as-an-adt">Skip lists as an ADT</a></li><li><a href="#searching">Searching</a></li><li><a href="#inserting">Inserting</a></li><li><a href="#deleting">Deleting</a></li><li><a href="#implementation">Implementation</a></li><li><a href="#performance">Performance</a></li></ul>
</div>
        </div>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS126/part8.html" title="Graph Related Pseudocode">üëàPrev</a><a href="./" title="CS126 Home">üè°CS126</a><a href="/CS126/pseudoCodes.html" title="Heaps">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h1 id="goals-for-skip-lists">Goals for skip lists</h1>

<ul>
  <li>The goal of skip lists is to efficiently implement searching, insertion and deletion</li>
  <li>For fast searching, we need the list to be sorted
    <ul>
      <li>We have come across two concrete implementations of lists, but neither of which fulfil all these goals
        <ul>
          <li>Sorted arrays
            <ul>
              <li>Easy to search using binary search, since they are not indexable, needs $O(log\ n)$ time</li>
              <li>Difficult insert/delete from, as elements need to be ‚Äúshuffled up‚Äù to maintain ordering, needs $O(n)$ time</li>
            </ul>
          </li>
          <li>Sorted lists
            <ul>
              <li>Easy to insert/delete from, assuming the position is known, needs $O(1)$ time</li>
              <li>Difficult to search, since they are not indexable, needs $O(n)$ time</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="skip-lists-as-an-adt">Skip lists as an ADT</h1>

<ul>
  <li>
    <p>Skip lists are composed from a number of sub-lists, which act as layers within them, which we denote by the set \(S = \{S_0, S_1, ..., S_h\}\) where \(h\) denotes the number of layers in the list, i.e. its ‚Äúheight‚Äù</p>
  </li>
  <li>
    <p>All lists have a guard values \(+ \infty\) and \(- \infty\) at either end, and all the elements are in order between those values</p>
  </li>
  <li>
    <p>The ‚Äúbottom‚Äù list, \(S_0\) contains all the values in order between the guards</p>
  </li>
  <li>
    <p>The ‚Äútop‚Äù list, \(S_h\), contains only the guard values, \(+ \infty\) and \(- \infty\)</p>
  </li>
  <li>
    <p>Each list \(S_i\) for \(0 &lt; i &lt; h\) (i.e. everything bar the top list, which contains only the guards, and the bottom list, which contains all elements) contains a random subset of the elements in the list below it, \(S_1\)</p>
  </li>
  <li>
    <p>The probability of an element in \(S_i\) being in the list above it, \(S_{i+1}\), is \(0.5\)</p>
  </li>
  <li>
    <p>A diagram of the structure of a skip list is shown below</p>

    <p><img src="./images/skipLists.png" alt="skipLists" /></p>

    <p>(<em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser)</p>
  </li>
</ul>

<h1 id="searching">Searching</h1>

<ul>
  <li>
    <p>To search for an value \(v\) in a skip list, we follow the algorithm</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Start at the first position in the top list (the top minus infinity guard)
  
Repeat
	//Scan forward step
	Repeat
		If the value of the right adjacent position is greater than that of the current position
			Break out of the loop
		Else if the value of the right adjacent position is equal to the current position
			Stop, since the element has been found
		Move to the right adjacent position
  		
	//Drop down step
	If there is a below adjacent position (you're not in the bottom list)
		Move to the below adjacent position
	Else (you're in the bottom list)
		Stop, since the element is not in the list
</code></pre></div>    </div>

    <p><img src="./images/skipListsSearch.png" alt="skipListsSearch" /></p>

    <p>(<em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser)</p>
  </li>
</ul>

<h1 id="inserting">Inserting</h1>

<ul>
  <li>
    <p>To insert a value \(v\) into a skip list, we follow the algorithm</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Let i &lt;- the number of flips of a fair coin before a head comes up
If i &gt;= h
	Add the new skip lists {S(h+1), ..., S(i+1)} to S, all by default only containing the guards
Find the positions p(1), ..., p(i) in all the the lists of the largest element less than v, using the search algorithm
For each j from 0 to i
	Insert k into S(j) immediately after the position p(j)
</code></pre></div>    </div>

    <p><img src="./images/skipListsInsertion.png" alt="skipListsInsertion" /></p>

    <p>(<em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser)</p>
  </li>
</ul>

<h1 id="deleting">Deleting</h1>

<ul>
  <li>
    <p>To delete a value \(v\) from a skip list, we follow the algorithm</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Find the positions p(1), ..., p(i) in all the the lists of the largest element less than v, using the search algorithm
Remove the postions  p(1), ..., p(i) from the lists S(0), ..., S(i)
Remove any duplicate list layers containing only guards from the top of the skip list
</code></pre></div>    </div>

    <p><img src="./images/skipListsDeletion.png" alt="skipListsDeletion" /></p>

    <p>(<em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser)</p>
  </li>
</ul>

<h1 id="implementation">Implementation</h1>

<ul>
  <li>
    <p>We can use ‚Äúquad-nodes‚Äù, which are similar to those used in linked lists, but with four pointers, instead of just one</p>

    <p><img src="./images/skipListsQuadNode.png" alt="skipListsQuadNode" /></p>

    <p>(<em>Data Structures and Algorithms in Java</em>, Goodrich, Tamassia, Goldwasser)</p>
  </li>
  <li>
    <p>This stores the entry, and links to the previous, next, below and above nodes</p>
  </li>
  <li>
    <p>Additionally, there are special guard nodes, with the values \(+ \infty\) and \(- \infty\)</p>
  </li>
</ul>

<h1 id="performance">Performance</h1>

<ul>
  <li>
    <p>Space usage</p>

    <ul>
      <li>
        <p>Dependent on randomly generated numbers for how many elements are in high layers, and how high the layers are</p>
      </li>
      <li>
        <p>We can find the expected number of node for a skip list of \(n\) elements:</p>

        <blockquote>
          <p>The probability of having \(i\) layers in the skip list is \(\frac{1}{2^i}\)</p>

          <p>The probability of having \(i\) layers in the skip list is \(\frac{1}{2^i}\)</p>

          <p>If the probability of any one of \(n\) entries being in a set is \(p\), the expected size of the set is \(n \cdot p\)</p>

          <p>Hence, the expected size of a list \(S_i\) is \(\frac{n}{2^i}\)</p>

          <p>This gives the expected number of elements in the list as \(\sum_{i=0}^{h}(\frac{n}{2^i})\)</p>

          <p>We can express this is \(n \cdot \sum_{i=0}^{h}(\frac{1}{2^i})\), and with the sum converging to a constant factor, so the space complexity is \(O(n)\)</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>The height of a skip list of \(n\) items is <strong>likely</strong> to (since it is generated randomly) have a height of order \(O(log\ n)\)</p>

    <ul>
      <li>
        <p>We show this by taking a height logarithmically related to the number of elements, and showing that the probability of the skip list having a height greater than that is very small</p>

        <blockquote>
          <p>The probability that a layer \(S_i\) has at least one item is at most \(\frac{n}{2^i}\)</p>

          <p>Considering a layer logarithmically related to the number of elements \(i = 3 \cdot log\ n\)</p>

          <p>The probability of the layer \(S_i\) has at least one entry is at most \(\frac{n}{2^{3 \cdot log\ n}} = \frac{n}{n^3} = \frac{1}{n^2}\)</p>

          <p>Hence, the probability of a skip list of \(n\) items having a height of more than \(3 \cdot log\ n\) is at most \(\frac{1}{n^2}\), which tends to a negligibly small number very quickly</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>Search time</p>

    <ul>
      <li>
        <p>Dependent on the number of steps (both scan forward and drop down) that need to be taken to find or verify the absence of the item</p>

        <ul>
          <li>
            <p>In the worst case, the both dimensions have to be totally traversed, if the item is both bigger than all other items, and not present</p>
          </li>
          <li>
            <p>The number of drop down steps is bounded by the height (\(\approx O(log\ n)\) with high probability)</p>
          </li>
          <li>
            <p>The expected number of scan forward steps in each list is \(2\), so the expected number of scan forward steps in total is \(O(log\ n)\)</p>

            <p><strong>If you can word a better explanation of this, please pull request</strong></p>
          </li>
          <li>
            <p>Hence, the total search time is \(O(log\ n)\)</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Update time</p>
    <ul>
      <li>Since the insert and delete operations are both essentially wrappers around the search operation, and all of their additional functionality is of \(O(log\ n)\) or better, the time complexity is the same as the search function</li>
    </ul>
  </li>
</ul>


                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub
                            Pages</a>.</span>
                </footer>
            </main>
        </div>
    </div>
</body>

</html>