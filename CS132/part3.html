<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="../assets/js/tocNav.js"></script>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Assembler | Computer Science Revision Guides</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Assembler" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Microprocessor Fundamentals" />
<meta property="og:description" content="Microprocessor Fundamentals" />
<link rel="canonical" href="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part3.html" />
<meta property="og:url" content="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part3.html" />
<meta property="og:site_name" content="Computer Science Revision Guides" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-12T14:53:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Assembler" />
<script type="application/ld+json">
{"description":"Microprocessor Fundamentals","headline":"Assembler","dateModified":"2021-05-12T14:53:39+00:00","datePublished":"2021-05-12T14:53:39+00:00","url":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part3.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part3.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/pages/CSRG-Group/dcs-notes.github.io/assets/css/style.css?v=c7cba74afde9610b1e7114060896a196d092ead3">
</head>

<body>
    <header style="padding:10px;" class="page-header" role="banner">
        <h1 class="project-name">Assembler</h1>
    </header>
    <div id="mainGrid" class="container">
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#microprocessor-fundamentals">Microprocessor Fundamentals</a><ul><li><a href="#fde-components">FDE Components</a></li></ul></li><li><a href="#registers">Registers</a><ul><li><a href="#data-registers">Data registers</a></li><li><a href="#status-registers">Status registers</a></li><li><a href="#address-register">Address register</a><ul><li><a href="#stack-pointer">Stack pointer</a></li></ul></li><li><a href="#program-counter">Program counter</a></li></ul></li><li><a href="#register-transfer-language">Register Transfer Language</a><ul><li><a href="#example-instruction-fetching">Example: Instruction fetching</a></li></ul></li></ul></li><li><a href="#assembly-language">Assembly Language</a><ul><li><a href="#assembler-format">Assembler Format</a></li><li><a href="#assembly-language-conventions">Assembly Language Conventions</a></li><li><a href="#data-types-and-assembler-instructions">Data types and assembler instructions</a></li></ul></li><li><a href="#instruction-set-aspects">Instruction set aspects</a><ul><li><a href="#data-movement-instructions">Data Movement Instructions</a></li><li><a href="#arithmetic-instructions">Arithmetic Instructions</a></li><li><a href="#logical-instructions">Logical instructions</a></li><li><a href="#branch-instructions">Branch instructions</a></li><li><a href="#subroutines-and-stacks">Subroutines and Stacks</a></li></ul></li><li><a href="#addressing-modes">Addressing modes</a></li></ul>
</div>
        </div>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="/CS132/part2.html" title="Memory Systems">üëàPrev</a><a href="./" title="CS132 Home">üè°CS132</a><a href="/CS132/part4.html" title="Digital Logic">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h1 id="microprocessor-fundamentals">Microprocessor Fundamentals</h1>

<p>Before diving into assembler, we need to be familiar with the <strong>key components of all CPUs</strong>. No matter how complex a CPU is, they always have the two following components.</p>

<ul>
  <li><strong>Arithmetic Logic Unit</strong> (ALU): this performs <strong>math and logic</strong></li>
  <li><strong>Control Unit</strong> (CU): this decodes program <strong>instructions</strong> and handles <strong>logistics</strong> for execution</li>
</ul>

<blockquote>
  <p>The CPU will constantly perform the following instruction cycle (the <strong>fetch-decode-execute cycle</strong>):</p>
  <ul>
    <li>Retrieve instructions from memory</li>
    <li>Decode to form recognisable operations</li>
    <li>Execute to impact the current state</li>
  </ul>
</blockquote>

<p>‚ùï‚ùó <strong>Learn the fetch-decode-execute cycle</strong>. Think of it every time you look at a CPU, or a series of instructions. Think about which of the components (the CU or the ALU) are operating and when.</p>

<p>The instruction cycle takes place over <strong>several CPU clock cycles</strong> ‚Äì the same clock cycles we saw in <strong>sequential logic circuits</strong>. The FDE cycle relies on several CPU components interacting with one another.</p>

<h2 id="fde-components">FDE Components</h2>
<p>There are several components that make up the FDE cycle:</p>
<ul>
  <li>ALU</li>
  <li>CU</li>
  <li><strong>Program Counter</strong> (PC): this tracks the <strong>memory address</strong> of the <strong>next instruction</strong> for execution</li>
  <li><strong>Instruction Register</strong> (IR): contains the <strong>most recent instruction</strong> fetched</li>
  <li><strong>Memory Address Register</strong> (MAR): contains the address of the <em>region</em> of memory for read/write purposes</li>
  <li><strong>Memory Data Register</strong> (MDR): contains <strong>fetched data</strong> from memory or <strong>data ready to be written</strong> to memory. The MDR is also sometimes referred to as the Memory Buffer Register (MBR).</li>
</ul>

<blockquote>
  <p>Remember that the <strong>Control Unit</strong> is connected to all components</p>
</blockquote>

<p>A typical instruction cycle may look something like this:</p>

<table>
  <thead>
    <tr>
      <th>Fetch</th>
      <th>Decode</th>
      <th>Execute</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1. Instruction Received from memory location in PC<br />2. Retrieved instruction stored in IR<br />3. PC incremented to point to next instruction in memory</td>
      <td>1. Opcode retrieved / instruction decoded<br />2. Read effective address to establish opcode type</td>
      <td>1. CU signals functional CPU components<br />2. Can result in changes to data registers, such as the PC etc.<br />3. PC incremented to point to next instruction in memory</td>
    </tr>
  </tbody>
</table>

<h1 id="registers">Registers</h1>

<p>Now that we have the FDE cycle established, we need <strong>registers</strong> to help store intermediate information- this can either be in the form of memory or system flags. The Motorola 68008 will be used to give context to each type of register:</p>

<blockquote>
  <p>You can think of a register as a parallel set of bits which can be toggled on or off.</p>
</blockquote>

<h2 id="data-registers">Data registers</h2>
<ul>
  <li>These are useful for storing <strong>frequently used values</strong> or <strong>intermediate results</strong> of calculations.</li>
  <li>You typically <strong>only need one</strong> data register <strong>on chip</strong> ‚Äì however, the advantage of having many registers is that <strong>fewer references to external memory are needed</strong>.</li>
</ul>

<blockquote>
  <p>The 68008 has 32 bit data registers. This is a <em>long</em> register; 16 bits form a <em>word</em>, and 8 bits form a <em>byte</em>.</p>
</blockquote>

<h2 id="status-registers">Status registers</h2>
<ul>
  <li>These have various status bits that are set or reset by the <strong>ALU</strong>.</li>
  <li>They are a <em>set of flags</em>:
    <ul>
      <li>Half are for the <strong>system</strong> (CU)</li>
      <li>The <strong>conditional control register</strong> is a <strong>subset of flags</strong></li>
    </ul>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">‚¨Ö System byte ‚û°</th>
      <th style="text-align: center">‚¨Ö User byte ‚û°</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">8 bits</td>
      <td style="text-align: center">8 bits, where a few bits will make up the CCR</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>The CCR is made up of several bits representing statuses such as <em>extend, negative, zero, overflow, carry</em>. If you wanted to check the status of the computer in a program, you could use bitwise <strong>AND</strong> against a bitmask (the string of bits you want toggled) and seeing if the final result is the flag you wanted to see.</p>
</blockquote>

<h2 id="address-register">Address register</h2>
<ul>
  <li>These are used as <strong>pointer registers</strong> in the calculation of operand addresses.</li>
  <li>Operations on these addresses <strong>do not alter the CCR</strong>.</li>
  <li>Only the <strong>ALU</strong> has the capacity to incur changes in status (through operations on non-addresses).</li>
</ul>

<h3 id="stack-pointer">Stack pointer</h3>
<ul>
  <li>This is an <strong>address register</strong> that points to the <strong>next free location</strong>; it can hold <strong>subroutine return addresses</strong>.</li>
</ul>

<blockquote>
  <p>The 68008 has pointer registers <code class="language-plaintext highlighter-rouge">A0-A6</code> whilst <code class="language-plaintext highlighter-rouge">A7</code> is used as a system stack pointer.</p>
</blockquote>

<h2 id="program-counter">Program counter</h2>
<p>We are already familiar with what the PC does ‚Äì it is a <strong>32 bit</strong> register on the 68008 that keeps track of the address at which the next instruction will be found.</p>

<blockquote>
  <p>If you were writing a software emulator, think of the memory as an array of strings (each string is an opcode). The PC would be an integer; your code would access <code class="language-plaintext highlighter-rouge">memory[PC]</code> to find out which opcode to pull from the memory and decode. Therefore, by incrementing the PC (an 8-bit, 16-bit, or 32-bit integer in your code) you can increment through the memory array. You can sometimes increment the PC by multiple amounts.
Generally speaking, if you were to be writing an emulator for any CPU, you <em>could</em> represent each register as an n-bit unsigned integer as you can toggle bits and perform bitwise operations, including bitshifts, on each integer variable. You would typically want to implement memory as a simple array of m-bit integers, where m is the word length of your CPU.</p>
</blockquote>

<h1 id="register-transfer-language">Register Transfer Language</h1>

<blockquote>
  <p>RTL is used to describe the operations of the microprocessor as it is executing program instructions.
It is also a way of making sure we access the correct parts of the microprocessor ‚Äì <strong>do not confuse it with assembler instructions</strong>.</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Example RTL</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[MAR] ‚¨Ö [PC]</code></td>
      <td><em>Transfer</em> the contents of the PC <strong>to</strong> the MAR</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[MS(12345)]</code></td>
      <td>The <em>contents</em> of memory <em>location</em> 12345 in the <em>main store</em></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">[D1(0:7)] &lt;- [D0(0:7)]</code></td>
      <td><i>Transfer</i> the contents of the 1st 8bits of <code class="language-plaintext highlighter-rouge">D0</code> to the 1st 8bits of <code class="language-plaintext highlighter-rouge">D1</code></td>
    </tr>
  </tbody>
</table>

<h3 id="example-instruction-fetching">Example: Instruction fetching</h3>
<p>Given a series of instructions in words, we can find a way to represent this in RTL. Consider the following example:</p>

<table>
  <thead>
    <tr>
      <th>Plain words</th>
      <th>RTL equivalent</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Contents of PC transferred to MAR address buffers</td>
      <td><code class="language-plaintext highlighter-rouge">[MAR] ‚¨Ö [PC]</code></td>
    </tr>
    <tr>
      <td>Increment the PC</td>
      <td><code class="language-plaintext highlighter-rouge">[PC] ‚¨Ö [PC] + 1</code></td>
    </tr>
    <tr>
      <td>Load MBR from external memory, and set \(R / \bar W\) to Read</td>
      <td><code class="language-plaintext highlighter-rouge">[MBR] ‚¨Ö [MS([MAR])]</code>; \(R / \bar W\) to Read</td>
    </tr>
    <tr>
      <td>Transfer opcode to IR from MBR</td>
      <td><code class="language-plaintext highlighter-rouge">[IR] ‚¨Ö [MBR]</code></td>
    </tr>
    <tr>
      <td>Decode the instruction</td>
      <td><code class="language-plaintext highlighter-rouge">CU ‚¨Ö [IR(opcode)]</code></td>
    </tr>
  </tbody>
</table>

<p>If you wanted to add a constant byte to a register (take <code class="language-plaintext highlighter-rouge">D0</code> from the 68008), you would engage the ALU and then transfer this into a register:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ continue previous cycle }
[MBR] ‚¨Ö [MS([MAR])]
ALU ‚¨Ö [MBR] + D0
[DO] ‚¨Ö ALU
</code></pre></div></div>
<p>As you can see, RTL describes how we can specifically set values in registers and interact with components in a standardised language.</p>

<h1 id="assembly-language">Assembly Language</h1>

<p><em>You should be able to explain the motivations, applications, and characteristics of high-level and low-level programming languages.</em></p>

<p>Code written in high-level programming languages typically go through a compiler, or for some languages like Python an <a href="https://www.computerscience.gcse.guru/theory/translators">interpreter</a> (FYI only), and is eventually <strong>translated</strong> into machine code that your microprocessor understands. Low-level assembly code is <strong>assembled</strong> by an assembler into machine code.</p>

<blockquote class="extra">
    Sometimes, the compilation process first compiles code into a lower-level assembly language and then the assembler assembles it into machine code, but in other cases high-level languages can be translated directly to machine code.
    I previously had the misunderstanding that high-level languages are
    <strong>always</strong> compiled to some kind of assembler language and is then 
    assembled to machine code, but this is not the case.
</blockquote>

<p>The <strong>motivation</strong> for low-level languages is to give programmers more <strong>control</strong> of how the microprocessor executes a particular program, as it allows you to define the exact sequence of instructions that will be executed by the microprocessor. High-level programming languages don‚Äôt have the capability to provide such specific instructions. Sometimes, this means that the resultant machine code has <strong>greater performance</strong> than one that was compiled from a high-level language.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">High-level Language</th>
      <th style="text-align: center">Machine Code</th>
      <th style="text-align: center">Assembler Language</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Human readable. <br />Difficult to translate into performant machine code whilst retaining original intention.</td>
      <td style="text-align: center">Not readable.</td>
      <td style="text-align: center">More readable than machine code but more precise than high-level languages.</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Assembly language saves us from machine code by using <strong>mnemonics</strong>. We can provide <strong>memory locations</strong> and <strong>constants</strong>, as well as <strong>symbolic names</strong>. These features are not afforded to us by RTL!</p>
</blockquote>

<h2 id="assembler-format">Assembler Format</h2>

<p>Assembly language typically takes the following form:</p>

<table class="centeredtable">
  <thead>
    <tr>
      <th style="text-align: center">¬†</th>
      <th style="text-align: center">Label (Optional)</th>
      <th style="text-align: center">Opcode</th>
      <th style="text-align: center">Operand</th>
      <th style="text-align: center">Comment</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Example</strong></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">START:</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">move.b</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">#5, D0</code></td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">|load D0 with 5</code></td>
    </tr>
  </tbody>
</table>

<h2 id="assembly-language-conventions">Assembly Language Conventions</h2>

<p>There are several conventions of Assembly language to keep in mind:</p>

<table>
  <thead>
    <tr>
      <th>Number Symbol</th>
      <th>Meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">#</code></td>
      <td>Indicates a constant. A number without <code class="language-plaintext highlighter-rouge">#</code> is an address. By default, numbers are in base 10.</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">$</code></td>
      <td>A <strong>hex</strong> value. E.g. <code class="language-plaintext highlighter-rouge">ORG $4B0 | this program starts at hex 4B0</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">%</code></td>
      <td>A <strong>binary</strong> value. E.g. <code class="language-plaintext highlighter-rouge">add.b #%11, D0 | add 3 to D0</code></td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<table>
  <thead>
    <tr>
      <th>Directives</th>
      <th>Definition</th>
      <th>Convention</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Label names</td>
      <td>You can assign labels to represent bytes or instructions</td>
      <td>Label or name followed by <code class="language-plaintext highlighter-rouge">:</code></td>
      <td><code class="language-plaintext highlighter-rouge">ANS: DS.B 1</code> will leave 1 byte of memory empty and name it ANS</td>
    </tr>
    <tr>
      <td>Defining storage (<code class="language-plaintext highlighter-rouge">DS</code>)</td>
      <td>Instruct the assembler to reserve some memory</td>
      <td><code class="language-plaintext highlighter-rouge">DS.{data type} {amount}</code></td>
      <td><code class="language-plaintext highlighter-rouge">DS.B 1</code> will leave 1 byte of memory free. See data types further on.</td>
    </tr>
    <tr>
      <td>Origin (<code class="language-plaintext highlighter-rouge">ORG</code>)</td>
      <td>Tells the assembler where in memory to start putting the instructions or data</td>
      <td><code class="language-plaintext highlighter-rouge">ORG</code> followed by value</td>
      <td><code class="language-plaintext highlighter-rouge">ORG $4B0</code> starts the program at hex <code class="language-plaintext highlighter-rouge">4B0</code></td>
    </tr>
  </tbody>
</table>

<p>If you want to string together an assembler instruction, you typically write them in the form
<code class="language-plaintext highlighter-rouge">operation.datatype</code>  <code class="language-plaintext highlighter-rouge">source,</code>   <code class="language-plaintext highlighter-rouge">destination</code></p>

<h2 id="data-types-and-assembler-instructions">Data types and assembler instructions</h2>

<p>Previously, we saw how the <code class="language-plaintext highlighter-rouge">DS</code> directive requires a data type and then an amount of data to set aside; Assembler language defines three types of data type:</p>
<ul>
  <li><strong>8 bits / byte</strong>: <code class="language-plaintext highlighter-rouge">.b</code></li>
  <li><strong>2 bytes / word</strong>: <code class="language-plaintext highlighter-rouge">.w</code></li>
  <li><strong>4 bytes / long word</strong>: <code class="language-plaintext highlighter-rouge">.l</code></li>
</ul>

<blockquote>
  <p>You can typically omit the data type and <code class="language-plaintext highlighter-rouge">.</code> if you are working with a <strong>word</strong>.</p>
</blockquote>

<h1 id="instruction-set-aspects">Instruction set aspects</h1>

<p>Generally speaking, there are two aspects to a CPU instruction set:</p>
<ul>
  <li><strong>Instructions</strong> which tell the processor which operations to perform
    <ul>
      <li>Data movement: this is similar to what we have already seen with RTL</li>
      <li>Arithmetic instructions: keep in mind whether your CPU can operate on fractional numbers</li>
      <li>Logical instructions</li>
      <li>Branch instructions</li>
      <li>System control instructions</li>
    </ul>
  </li>
  <li><strong>Addressing modes</strong> tell the processor which ways it can access data or memory locations, or how they may be calculated by the CPU.</li>
</ul>

<blockquote>
  <p>Addressing modes can provide data, specify where it is, and how to go find it.
You may describe direct addresses, or relative addresses where you compare one address to another to find it.</p>
</blockquote>

<h2 id="data-movement-instructions">Data Movement Instructions</h2>

<p>The <code class="language-plaintext highlighter-rouge">move</code> operations are similar to RTL, just pay attention to the data type.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>move.b D0,D1  | [D1(0:7)] &lt;- [D0(0:7)]
moveb  D0,D1  | same
exg.b  D4,D5  | exchange contents of two registers
swap   D2     | swap lower and upper words of D2
lea  $F20,A3  | load effective address [A3] &lt;- [$F20]
</code></pre></div></div>

<h2 id="arithmetic-instructions">Arithmetic Instructions</h2>

<p>Depending on your processor architecture, you may or may not have floating point support.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>add.l  Di,Dj  | [Dj] &lt;- [Di] + [Dj]
addx.w Di,Dj  | also add in x bit from CCR
mulu.w Di,Dj  | [Dj(0:31)] &lt;- [Di(0:15)] * [Dj(0:15)] signed multiplication
</code></pre></div></div>

<p>You also have <code class="language-plaintext highlighter-rouge">sub</code> (subtract), <code class="language-plaintext highlighter-rouge">mulu</code> (unsigned mult), <code class="language-plaintext highlighter-rouge">divu</code> and <code class="language-plaintext highlighter-rouge">divs</code>. You don‚Äôt have to memorise or know these very well but the key takeaways are</p>

<ul>
  <li>The ‚Äúvariables‚Äù (around the comma <code class="language-plaintext highlighter-rouge">,</code>) are operated on sequentially (left to right).</li>
  <li>The result of the operation is stored in the second variable (after the comma <code class="language-plaintext highlighter-rouge">,</code>).</li>
  <li>You can add or subtract bits from the CCR</li>
  <li>Division and multiplication use the first half of the bits available (unless specified) because the resultant register has a fixed bit length (32 bits in the above example).</li>
</ul>

<h2 id="logical-instructions">Logical instructions</h2>

<p>We can often use <strong>bitmasks</strong> to achieve our goals in conjunction with <strong>bitwise operations</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AND.B #%11110000, D3 | bitwise AND on 1111 0000 and first 8bits of D3
</code></pre></div></div>

<p>Additional pointers:</p>

<ul>
  <li><strong>Shift operations</strong> are fundamental; for example, you can multiply by 2 using left shift operations.</li>
  <li>Other operations such as rotations also exist.</li>
</ul>

<h2 id="branch-instructions">Branch instructions</h2>
<p>These are crucial for <strong>control flow statements</strong>; we typically branch based on <strong>conditions set in the CCR</strong>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LDA NumA | Read the value "NumA"
CMP NumB | Compare against "NumB"
BCC Loc  | Go to label "Loc" if "NumA" &lt; "NumB", or in RTL: [PC] &lt;- Loc
</code></pre></div></div>

<p><a href="https://www.c64-wiki.com/wiki/BCC">Example</a> for illustration purposes (we don‚Äôt need to know what <code class="language-plaintext highlighter-rouge">LDA</code> or <code class="language-plaintext highlighter-rouge">CMP</code> is exactly just roughly understand the syntax). Branch instructions cause the processor to branch (jump) to a labelled address.</p>

<ul>
  <li>CCR flags are set by the previous instruction</li>
  <li>The current instruction can test the state of the CCR bits and branch if a certain <strong>condition</strong> is met.</li>
</ul>

<h2 id="subroutines-and-stacks">Subroutines and Stacks</h2>
<p>Subroutines (<code class="language-plaintext highlighter-rouge">JSR</code>; jump, <code class="language-plaintext highlighter-rouge">RTS</code>; return) let you use the <strong>same code repeatedly</strong> reducing program size and improving readability. It is similar to functions.</p>

<p>Typically when a subroutine is called (with <code class="language-plaintext highlighter-rouge">JSR &lt;subroutine label&gt;</code>), the current address in the PC is <strong>pushed</strong> to a stack and your stack pointer points to the newly pushed address (current address). The address of the subroutine is ‚Äúloaded‚Äù into the PC and the instructions in the subroutine is executed.</p>

<p>When <code class="language-plaintext highlighter-rouge">RTS</code> is called, the stack is <strong>popped</strong> and the <strong>popped address</strong> is put into the PC; the stack pointer points to the next address at the top of the stack.</p>

<h1 id="addressing-modes">Addressing modes</h1>
<p>As mentioned earlier, there are several ways for the CPU to access memory; you should be familiar with the following, and they are found on many CPUs (not just the 68008):</p>

<table>
  <thead>
    <tr>
      <th>Address type</th>
      <th>Definition</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Direct address</td>
      <td>Explicitly specifying two registers in the same command</td>
      <td><code class="language-plaintext highlighter-rouge">move D3, D2</code></td>
    </tr>
    <tr>
      <td>Immediate address</td>
      <td>The <strong>operand</strong> forms part of the instruction and <strong>remains constant</strong></td>
      <td><code class="language-plaintext highlighter-rouge">move.b #$42, D5</code></td>
    </tr>
    <tr>
      <td>Absolute address</td>
      <td>This <strong>specifies the destination location explicitly</strong></td>
      <td><code class="language-plaintext highlighter-rouge">move.l D2, $7FFF0</code> which moves the long value held in D2 to address <code class="language-plaintext highlighter-rouge">$7FFF0</code></td>
    </tr>
    <tr>
      <td>Relative address</td>
      <td>These all <strong>relate to the program counter</strong> to write <strong>position independent code</strong></td>
      <td><code class="language-plaintext highlighter-rouge">move d16(PC), D3</code> move contents that are located in the address +16 addresses from PC to <code class="language-plaintext highlighter-rouge">D3</code></td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Indirect addressing is never on the exam; however, this is where we add offsets, increments, or indexed addressing to access memory or data.</p>
</blockquote>

                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub
                            Pages</a>.</span>
                </footer>
            </main>
        </div>
    </div>
</body>

</html>