<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="../assets/js/tocNav.js"></script>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Data Representation | Computer Science Revision Guides</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Data Representation" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Representation and number systems" />
<meta property="og:description" content="Representation and number systems" />
<link rel="canonical" href="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part1.html" />
<meta property="og:url" content="https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part1.html" />
<meta property="og:site_name" content="Computer Science Revision Guides" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-12T14:53:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Data Representation" />
<script type="application/ld+json">
{"description":"Representation and number systems","headline":"Data Representation","dateModified":"2021-05-12T14:53:39+00:00","datePublished":"2021-05-12T14:53:39+00:00","url":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part1.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/CS132/part1.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/pages/CSRG-Group/dcs-notes.github.io/assets/css/style.css?v=c7cba74afde9610b1e7114060896a196d092ead3">
</head>

<body>
    <header style="padding:10px;" class="page-header" role="banner">
        <h1 class="project-name">Data Representation</h1>
    </header>
    <div id="mainGrid" class="container">
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#representation-and-number-systems">Representation and number systems</a><ul><li><a href="#sizes-of-symbols">Sizes of symbols</a></li></ul></li><li><a href="#why-do-we-use-binary">Why do we use Binary?</a><ul><li><a href="#what-is-noise-immunity">What is Noise Immunity?</a></li></ul></li><li><a href="#bits-bytes-words-and-bus-sizes">Bits, Bytes, Words, and Bus sizes</a></li><li><a href="#conversion">Conversion</a></li><li><a href="#converting-from-decimal-to-binary">Converting from Decimal to Binary</a><ul><li><a href="#decimal-to-octal-or-hex">Decimal to Octal or Hex</a></li></ul></li><li><a href="#addition-and-negative-numbers">Addition and Negative Numbers</a><ul><li><a href="#twos-complement-representation">Two‚Äôs Complement Representation</a></li></ul></li><li><a href="#fractional-numbers">Fractional Numbers</a><ul><li><a href="#fixed-point-representation">Fixed Point Representation</a></li><li><a href="#floating-point-representation">Floating Point Representation</a></li></ul></li></ul>
</div>
        </div>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="./" title="CS132 Home">üè°CS132</a><a href="/CS132/part2.html" title="">Nextüëâ</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Each module has its own layout to allow module layouts to be customised -->
<!-- The layout name is also used by the notes layout to display the correct module code -->

<h2 id="representation-and-number-systems">Representation and number systems</h2>

<p>In terms of the exam, the most important concept is <strong>value versus representation</strong> of any number. In practice, this means you need to accept that you cannot always represent a value across different bases using the same number of symbols.</p>

<blockquote>
  <p><strong>One value, many representations.</strong> A representation is a way of using or describing a value, for example \(1010_2\) and \(10_{10}\) denote the same value.</p>
</blockquote>

<p>There are four main number systems we will use:</p>

<table>
  <thead>
    <tr>
      <th>Number system</th>
      <th>Symbols</th>
      <th>Base</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Binary</td>
      <td><code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code></td>
      <td>2</td>
    </tr>
    <tr>
      <td>Octal</td>
      <td><code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>, <code class="language-plaintext highlighter-rouge">6</code>, <code class="language-plaintext highlighter-rouge">7</code></td>
      <td>8</td>
    </tr>
    <tr>
      <td>Decimal</td>
      <td><code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>, <code class="language-plaintext highlighter-rouge">6</code>, <code class="language-plaintext highlighter-rouge">7</code>, <code class="language-plaintext highlighter-rouge">8</code>, <code class="language-plaintext highlighter-rouge">9</code></td>
      <td>10</td>
    </tr>
    <tr>
      <td>Hex</td>
      <td><code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, <code class="language-plaintext highlighter-rouge">4</code>, <code class="language-plaintext highlighter-rouge">5</code>, <code class="language-plaintext highlighter-rouge">6</code>, <code class="language-plaintext highlighter-rouge">7</code>, <code class="language-plaintext highlighter-rouge">8</code>, <code class="language-plaintext highlighter-rouge">9</code>, <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>, <code class="language-plaintext highlighter-rouge">C</code>, <code class="language-plaintext highlighter-rouge">D</code>, <code class="language-plaintext highlighter-rouge">E</code>, <code class="language-plaintext highlighter-rouge">F</code></td>
      <td>16</td>
    </tr>
  </tbody>
</table>

<p>It is crucial that you learn to distinguish between representations of these numbers ‚Äì for example, 16<sub>10</sub> = 10000<sub>2</sub> = 20<sub>8</sub> = 10<sub>16</sub>.</p>

<p>For any number system, you can use the following equation to calculate the value of a number:</p>

\[\text{value = (sum from } i = 0\text{ to } i = (N-1))\text{ symbol}(i) \times \text{base}^i\]

<h3 id="sizes-of-symbols">Sizes of symbols</h3>
<p>As the base increases, we can see that a single symbol can represent bases more concisely than in other bases ‚Äì take the following examples:</p>
<ul>
  <li>Octal symbols can represent 3 bits:
    <ul>
      <li>111<sub>2</sub> = 7<sub>8</sub></li>
      <li>010 100 011<sub>2</sub> = 243<sub>8</sub></li>
    </ul>
  </li>
  <li>Hex symbols can represent four bits:
    <ul>
      <li>1111<sub>2</sub> = 15<sub>10</sub> = F<sub>16</sub></li>
      <li>1010 0011<sub>2</sub> = A3<sub>16</sub></li>
    </ul>
  </li>
</ul>

<p>A decimal symbol requires roughly <strong>3.3 bits</strong>, and therefore hex and octal are much more convenient when describing values on a bus.</p>

<h2 id="why-do-we-use-binary">Why do we use Binary?</h2>

<p>Mainly because 0s and 1s provide the greatest degree of distinction for voltage levels which gives us <strong>noise immunity</strong>.</p>

<h3 id="what-is-noise-immunity">What is Noise Immunity?</h3>

<p>In <em>TTL (transistor-transistor logic)</em>, we use two voltage ranges to determine when we register a <code class="language-plaintext highlighter-rouge">0</code> or a <code class="language-plaintext highlighter-rouge">1</code>:</p>

<table>
  <thead>
    <tr>
      <th>Voltage</th>
      <th>Signal</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0V - 0.8V</td>
      <td>0</td>
    </tr>
    <tr>
      <td>2.4V - 5V</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>These are ranges are governed by the tolerance of the electrical components and can be affected by <em>noise</em> that makes the voltage fluctuate. Hence there is a ‚Äúdivide‚Äù between the 2 ranges to provide a separation for the signal, in order to properly distinguish between a 0 or 1.</p>

  <p>Otherwise, if the cut-off point was just at a particular voltage, e.g. \(3V\), then if it is at \(2.9V\) the transistor will not know if it is a \(0\) or a \(1\) because there will be fluctuations (noise).</p>
</blockquote>

<p>Now we can carry this information on a wire and usually we have multiple wires running in parallel, which is known as a <strong>parallel bus</strong> (a collection of wires communicating a value between sub-circuits).</p>

<h2 id="bits-bytes-words-and-bus-sizes">Bits, Bytes, Words, and Bus sizes</h2>

<p>You need to understand and recall the value ranges (or size) of the aforementioned terms:</p>

<table>
  <thead>
    <tr>
      <th>Magic word</th>
      <th>Explanation</th>
      <th>Value range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bit</td>
      <td>Binary digit</td>
      <td>Values 0<sub>2</sub> or 1<sub>2</sub> inclusive</td>
    </tr>
    <tr>
      <td>Byte</td>
      <td>8 bits</td>
      <td>Values 0<sub>10</sub> to 255<sub>10</sub> inclusive</td>
    </tr>
    <tr>
      <td>Nibble</td>
      <td>4 bits</td>
      <td>Values 0<sub>10</sub> to 15<sub>10</sub> inclusive</td>
    </tr>
    <tr>
      <td>Word</td>
      <td>The number of <strong>bits</strong> a machine can <strong>process simultaneously</strong></td>
      <td>Machine specific ‚Äì increasing over time</td>
    </tr>
  </tbody>
</table>

<p>The <strong>disadvantages</strong> of increased word size are increased CPU, bus, and memory complexity. This results in an <strong>exponential increase in cost</strong>.</p>

<p><strong>MSB</strong> (most significant bit) and <strong>LSB</strong> (least significant bit), usually the leftmost and rightmost bit respectively. There are exceptions when you want to flip it around, and that should in such cases you should explicitly state which bit you are referring to.</p>

<h2 id="conversion">Conversion</h2>

<p>One disadvantage of binary is that it is <strong>not</strong> a very <strong>compact</strong> way of representing values. So for representing larger values for humans, we usually use octal or hexadecimal, why? because‚Ä¶</p>

<p><em>It is easier to convert from binary to octal or binary to hexadecimal than from binary to decimal</em></p>

<p>One octal symbol can represent 3 bits 
\(010_2 = 2_8, 100_2 = 4_8,011_2 = 3_8 \\
010\;100\;011_2 = 243_8\)
One hex can represent 4 bits
\(1010\;0011_2=A3_{16}\)
One decimal symbol requires 3.333‚Ä¶ bits, so hex and octal are more convenient.</p>

<h2 id="converting-from-decimal-to-binary">Converting from Decimal to Binary</h2>

<p>Repeatedly divide the number by the base required, i.e 2 for binary, and record the remainder for each division. Once you‚Äôre done, write out the remainders from quotient 0 to the original number (in this case right to left) and you will arrive at the binary representation of your original number.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Quotient</th>
      <th style="text-align: center">163</th>
      <th style="text-align: center">81</th>
      <th style="text-align: center">40</th>
      <th style="text-align: center">20</th>
      <th style="text-align: center">10</th>
      <th style="text-align: center">5</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">0</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><strong>Remainder</strong></td>
      <td style="text-align: center">-</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

\[163_{10} = 1010 \;0011_2\]

<h3 id="decimal-to-octal-or-hex">Decimal to Octal or Hex</h3>

<p>The same division method can be used‚Ä¶but it might be easier to convert to binary first and then into the required base:</p>

\[\begin{align}
23_{10} &amp;= 16 + 4 +2+1\\
&amp;=10111_2 \\
&amp;=27_8 (010\; 111_2) \\
&amp;= 17_{16} (0001\;0111_2)
\end{align}\]

<p>You can do this unless Matt prohibits it in exam. The best way to get better at this is by doing practice questions.</p>

<h2 id="addition-and-negative-numbers">Addition and Negative Numbers</h2>

<p>To do <strong>addition</strong> in binary it‚Äôs just like long division, sum the numbers, and carry over the 1 if there it adds to 2.</p>

<p><strong>Signed Magnitude Representation.</strong> This is 1 way of <em>representing negative numbers</em> in bits. The MSB is an indicator of whether the number is negative. 1 is negative, 0 is positive. However, there‚Äôs a problem when you think about 0. What is +0 vs -0? Our solution is to use two‚Äôs complement.</p>

<h3 id="twos-complement-representation">Two‚Äôs Complement Representation</h3>

<p>The MSB has the same value as in the binary positional representation but it is negative. This makes the range asymmetric from [-2<sup>n-1</sup>, 2<sup>n-1</sup> - 1] ‚Äì there are more negative numbers than positive as the MSB is negative. Because of this, it also makes the zero <strong>unique</strong>.</p>

<p>To get a negative number in two‚Äôs complement form from its positive number in binary.</p>

<ol>
  <li>Invert the bits ensuring there are enough bits for the MSB to be the sign</li>
  <li>Add 1, ignoring any overflow.</li>
</ol>

<p>Tada, now we can do subtraction by adding negative numbers in two‚Äôs complement form. Positive numbers in two‚Äôs complement are exactly the same as their binary form just that you have to include an extra bit (the MSB) that is 0.</p>

<p>The only thing to know for addition and subtraction in two‚Äôs complement is to ignore any carry to bits that are beyond the precision of the 2 numbers.</p>

<h2 id="fractional-numbers">Fractional Numbers</h2>

<h3 id="fixed-point-representation">Fixed Point Representation</h3>

<p>For fractions, we introduce inverse/decimal powers. \(2.75_{10}\) = \(10.11_2\).
\(\begin{align}
&amp;10.11_2&amp;            &amp;=&amp; &amp;1&amp;   &amp;0&amp;   &amp;1&amp;      &amp;1&amp;      \\
&amp;\text{Position:}&amp; &amp;&amp;  &amp;2^1&amp; &amp;2^0&amp; &amp;2^{-1}&amp; &amp;2^{-1}&amp; \\
&amp;&amp;                   &amp;=&amp; &amp;2&amp;    &amp;1&amp;    &amp;0.5&amp;       &amp;0.25&amp; \\
&amp;\text{Value}&amp;     &amp;=&amp; &amp;(1\times 2+&amp;    &amp;0\times1+&amp;    &amp;1\times0.5+&amp;   &amp;1\times0.25)&amp; \\
&amp;&amp;                   &amp;=&amp; &amp;2.75_{10}&amp;
\end{align}\)
However, if the number is 2.8‚Äã for example, <strong>Fixed-PR</strong> will not be very efficient because to represent it in binary will require a lot of bits. This means that in a microprocessor, we will need an incredibly large bus to represent such values. And so we use‚Ä¶</p>

<h3 id="floating-point-representation">Floating Point Representation</h3>

<p>Floating point uses the same principles as scientific notation. You should be familiar with <strong>Floating-PR</strong> from <a href="https://csrg-group.github.io/dcs-notes.github.io/cs118/part1.html">CS118</a>.</p>

<p><strong>IEEE Floating Point.</strong> IEEE standard 754 is widely used and specifies levels of binary precision</p>

<ul>
  <li>Single precision (32 bits) ‚Äì 1bit for the sign, 8bits for the exponent, and 23 bits for the mantissa</li>
  <li>Double precision (64 bits)</li>
  <li>Quad precision (128 bits)</li>
</ul>

                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub
                            Pages</a>.</span>
                </footer>
            </main>
        </div>
    </div>
</body>

</html>