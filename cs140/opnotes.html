<!DOCTYPE html>
<html lang=" en-US">

<head>

    
    <meta charset="UTF-8"><!-- Include tocNAV javascript -->
    <script type="text/javascript" src="../assets/js/tocNav.js"></script>

    <!-- Begin Jekyll SEO tag v2.7.1 -->
<title>140 One Page Notes | Computer Science Revision Guides</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="140 One Page Notes" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A collection of revision notes summarising modules taught on the Computer Science course at the University of Warwick" />
<meta property="og:description" content="A collection of revision notes summarising modules taught on the Computer Science course at the University of Warwick" />
<link rel="canonical" href="https://github.com/pages/CSRG-Group/dcs-notes.github.io/cs140/opnotes" />
<meta property="og:url" content="https://github.com/pages/CSRG-Group/dcs-notes.github.io/cs140/opnotes" />
<meta property="og:site_name" content="Computer Science Revision Guides" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-05-12T14:53:39+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="140 One Page Notes" />
<script type="application/ld+json">
{"description":"A collection of revision notes summarising modules taught on the Computer Science course at the University of Warwick","headline":"140 One Page Notes","dateModified":"2021-05-12T14:53:39+00:00","datePublished":"2021-05-12T14:53:39+00:00","url":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/cs140/opnotes","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/pages/CSRG-Group/dcs-notes.github.io/cs140/opnotes"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="preload" href="https://fonts.googleapis.com/css?family=Open+Sans:400,700&display=swap" as="style"
        type="text/css" crossorigin>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/pages/CSRG-Group/dcs-notes.github.io/assets/css/style.css?v=c7cba74afde9610b1e7114060896a196d092ead3">
</head>

<body>
    <header style="padding:10px;" class="page-header" role="banner">
        <h1 class="project-name">140 One Page Notes</h1>
    </header>
    <div id="mainGrid" class="container">
        <div class="navBox">
            <div id="sidenav" class="sideNav closedNav">
                <h2 style="margin-left: 10px;">Table of Contents</h2><ul><li><a href="#introduction-to-computer-security">Introduction to Computer Security</a></li><li><a href="#2-features-of-computer-security">2 Features of Computer Security</a></li><li><a href="#cia-triangle">CIA Triangle</a></li><li><a href="#case-studies">Case studies</a><ul><li><a href="#malware---the-morris-worm">Malware - The Morris worm</a><ul><li><a href="#worm-vs-virus">Worm vs Virus</a></li></ul></li><li><a href="#denial-of-service---takes-on-georgian-blogger">Denial of service - takes on Georgian blogger</a></li><li><a href="#hacktivism">Hacktivism</a></li><li><a href="#social-engineering">Social engineering</a></li><li><a href="#physical-security">Physical security</a></li></ul></li><li><a href="#basic-terminology">Basic Terminology</a><ul><li><a href="#asset">Asset</a></li><li><a href="#vulnerability">Vulnerability</a></li><li><a href="#threat">Threat</a></li><li><a href="#risk">Risk</a></li><li><a href="#attack">Attack</a></li><li><a href="#countermeasure">Countermeasure</a></li><li><a href="#trust">Trust</a></li></ul></li><li><a href="#risk-analysis">Risk Analysis</a><ul><li><a href="#qualitative-analysis">Qualitative analysis</a><ul><li><a href="#checklist-method">Checklist Method</a></li><li><a href="#mathematical-method">Mathematical Method</a></li></ul></li></ul></li><li><a href="#analysing-security-incidents">Analysing Security Incidents</a></li><li><a href="#authentication">Authentication</a></li><li><a href="#why-authentication">Why Authentication?</a></li><li><a href="#passwords">Passwords</a><ul><li><a href="#the-problem-with-passwords">The Problem with Passwords</a><ul><li><a href="#peoples-tendency-in-setting-passwords">People‚Äôs tendency in setting passwords</a></li><li><a href="#user-overload">User Overload</a></li></ul></li></ul></li><li><a href="#password-cracking">Password Cracking</a><ul><li><a href="#cracking-speed">Cracking Speed</a></li><li><a href="#password-strength">Password Strength</a><ul><li><a href="#human-generated-passwords">Human Generated Passwords</a></li></ul></li><li><a href="#password-hashing">Password Hashing</a></li></ul></li><li><a href="#other-authentication-methods">Other Authentication Methods</a></li><li><a href="#password-cracking">Password Cracking</a></li><li><a href="#methods">Methods</a></li><li><a href="#brute-force-and-dictionary-attacks">Brute Force and Dictionary Attacks</a><ul><li><a href="#brute-force-attacks">Brute Force Attacks</a></li><li><a href="#dictionary-attacks">Dictionary attacks</a></li></ul></li><li><a href="#lookup-tables">Lookup Tables</a></li><li><a href="#reverse-lookup-tables">Reverse Lookup Tables</a><ul><li><a href="#hash-chain">Hash Chain</a><ul><li><a href="#how-rlt-saves-space">How RLT saves space</a></li><li><a href="#false-alarms">False Alarms</a></li></ul></li></ul></li><li><a href="#rainbow-table">Rainbow Table</a><ul><li><a href="#cracking-passwords-in-rainbow-table">Cracking passwords in Rainbow Table</a></li></ul></li><li><a href="#defence">Defence</a><ul><li><a href="#password-salt">Password Salt</a><ul><li><a href="#how-does-salt-help-defend-against-table-attacks">How does salt help defend against table attacks?</a></li></ul></li></ul></li><li><a href="#how-are-hashes-stored-in-linux">How are hashes stored in Linux?</a><ul><li><a href="#unix-password-protection">Unix password protection</a></li></ul></li><li><a href="#cryptography">Cryptography</a></li><li><a href="#different-types-of-encryption">Different types of encryption</a></li><li><a href="#encryption-technique-properties">Encryption Technique Properties</a></li><li><a href="#secret-key-encryption">Secret key encryption</a></li><li><a href="#techniques-of-encryption">Techniques of Encryption</a><ul><li><a href="#steganography">Steganography</a><ul><li><a href="#hiding-data-in-an-image">Hiding data in an image</a><ul><li><a href="#lsb-insertion">LSB Insertion</a></li></ul></li></ul></li><li><a href="#code-words">Code Words</a></li><li><a href="#transpositionpermutation-cipher">Transposition/Permutation Cipher</a></li><li><a href="#monoalphabetic-substitution-cipher">Monoalphabetic Substitution Cipher</a></li><li><a href="#polyalphabetic-substitution-cipher">Polyalphabetic Substitution Cipher</a></li><li><a href="#one-time-pad">One time pad</a></li><li><a href="#combining-message-and-key">Combining message and key</a></li></ul></li><li><a href="#data-encryption-standard-des">Data Encryption Standard (DES)</a><ul><li><a href="#fiestal-approach-overview">Fiestal Approach Overview</a></li><li><a href="#the-round-function">The Round Function</a></li><li><a href="#subkey-generation-key-schedule">Subkey Generation (Key Schedule)</a><ul><li><a href="#permuted-choice-1">Permuted Choice 1</a></li><li><a href="#permuted-choice-2">Permuted Choice 2</a></li></ul></li></ul></li><li><a href="#advanced-encryption-standard-aes">Advanced Encryption Standard (AES)</a><ul><li><a href="#sub-operations">Sub-Operations</a><ul><li><a href="#subbytes">SubBytes</a></li><li><a href="#shiftrows">ShiftRows</a></li><li><a href="#mixcolumns">MixColumns</a></li><li><a href="#addroundkey">AddRoundKey</a></li></ul></li><li><a href="#aes-is-secure">AES is secure</a></li></ul></li><li><a href="#public-key-cryptography">Public Key Cryptography</a><ul><li><a href="#modular-arithmetic">Modular Arithmetic</a></li><li><a href="#the-primitive-root">The Primitive Root</a></li><li><a href="#public-key-encryption">Public Key Encryption</a></li><li><a href="#rsa-encryption">RSA Encryption</a><ul><li><a href="#finding-the-private-key">Finding the private key</a></li><li><a href="#why-is-rsa-secure">Why is RSA secure?</a></li></ul></li><li><a href="#public-key-vs-secret-key-encryption">Public key vs Secret key Encryption</a></li></ul></li></ul>
</div>
        </div>
        <div title="Table of Contents" class="buttonCol" onclick="toggleNav()">
            <div class="navArrow">
                <i></i>
            </div>
        </div>
        <div class="contents">
            <main id="content" class="main-content" role="main">
                <div class="partNav"><a href="./">üè°CS140</a></div>
                <!-- Main Content of markdown or sub-layouts-->
                <!-- Layout for One Page Notes -->
<!-- 
    Works for all modules as long as they 
    - Have part: true
    - Are defined as a collection in _config.yml
    - The folder name is "_[Module Code]"
--><h1 id="introduction-to-computer-security">Introduction to Computer Security</h1>
       
        <h1 id="2-features-of-computer-security">2 Features of Computer Security</h1>

<p><strong>There is no such thing as absolute computer security.</strong> If we want to know whether a system is secure, there are many questions to ask.</p>

<ul>
  <li>Security, in which aspects?
    <ul>
      <li>Secrecy</li>
      <li>damage prevention</li>
      <li>ensure services are available</li>
    </ul>
  </li>
  <li>Security from whom? All people or differentiate users?
    <ul>
      <li>It is harder to achieve different levels of security from different users.</li>
    </ul>
  </li>
  <li>Security to what level? Trade off between cost and performance
    <ul>
      <li>To achieve a higher level of security</li>
      <li>more investment</li>
      <li>more performance degradation</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Part of the reason why there is no 100% security is because there are too many security issues to consider. We can‚Äôt achieve 100% ‚Äì the aim is to <strong>reduce</strong> as much as possible.</p>
</blockquote>

<p><strong>Theory is not the same as practice.</strong> Security is not just about theory but also:</p>

<ul>
  <li><strong>Implementation.</strong> How the program is written. Is it accurately implementing theory?</li>
  <li><strong>Deployment.</strong> Private or public server? How can user input be transferred safely to servers?</li>
  <li><strong>Maintenance.</strong> Frequent security patches are needed.</li>
  <li><strong>Parties involved.</strong> Who uses the system and what is their security behaviour? Parties involved have to have secure habits.</li>
  <li><strong>Location.</strong> Where is the system used? Private or public domain?</li>
  <li><strong>Temptation.</strong> How tempting is the asset? There will always be black hats trying to attack the system.</li>
</ul>

<blockquote>
  <p>Beautiful cryptography can be regularly compromised by bad implementations (human error).</p>
</blockquote>

<h1 id="cia-triangle">CIA Triangle</h1>

<p>A security model that defines three key aspects that should be guaranteed at all times</p>

<ol>
  <li><strong>Confidentiality.</strong> No unauthorised disclosure.</li>
  <li><strong>Integrity.</strong> No unauthorised change</li>
  <li><strong>Availability.</strong> Users are not denied access to resources or have unwarranted delay.</li>
</ol>

<h1 id="case-studies">Case studies</h1>

<h2 id="malware---the-morris-worm">Malware - The Morris worm</h2>

<p>Robert Morris tried to measure the size of the Internet. The worm could get into a computer through rsh, generate a process and invoke the OS commands to obtain certain information about the network.</p>

<h3 id="worm-vs-virus">Worm vs Virus</h3>

<p>Both self-replicate and likely to achieve rapid population growth</p>

<ul>
  <li>Virus - replicate into other executable code and infect it</li>
  <li>Worm - standalone, doesn‚Äôt need a host program.</li>
  <li>Sometimes they are used interchangeably</li>
</ul>

<h2 id="denial-of-service---takes-on-georgian-blogger">Denial of service - takes on Georgian blogger</h2>

<p>Attackers sends a massive number of requests to access the service sites so that the sites are too busy to serve the requests from the genuine users</p>

<h2 id="hacktivism">Hacktivism</h2>

<p>Used as a protest action against governments/institutions.</p>

<p>Anonymous took down US government websites: White House, Department of Justice and FBI. Music sites like Universal Music was targeted too. Coordinated, decentralized, very effective.</p>

<h2 id="social-engineering">Social engineering</h2>

<p>Hacking a system doesn‚Äôt involve technical skills</p>

<ul>
  <li>Happens by exploiting people‚Äôs trust</li>
  <li>Con people into divulging personal info such as passwords
    <ul>
      <li>No technical skill, just social skills</li>
    </ul>
  </li>
  <li>Kevin Mitnick - notorious hacker in the 80s to 90s, wrote the Art of Deception book.</li>
</ul>

<h2 id="physical-security">Physical security</h2>

<p>Russian programmer taken hostage in 2010. People can be threatened, physical locations can be breached, dumpsters can be dived!</p>

<blockquote>
  <p><strong>This is why we say there is no such thing as 100% Com Sec.</strong></p>
</blockquote>

<h1 id="basic-terminology">Basic Terminology</h1>

<p>Before we dive into risk analysis methods, we will cover basic terminology in security.</p>

<h2 id="asset">Asset</h2>

<blockquote>
  <p>Anything we value enough so that we want to protect it</p>
</blockquote>

<p><strong>Examples</strong>:</p>

<ul>
  <li>Customer database, web page, source code or executables of programs</li>
  <li>Laptop, mobile phone, staff, customers, consultants.</li>
  <li>Company reputation</li>
</ul>

<h2 id="vulnerability">Vulnerability</h2>

<blockquote>
  <p>A flaw or weakness in a system‚Äôs design, implementation, or operation and management that could be exploited to violate the system‚Äôs security policy.</p>
</blockquote>

<p><strong>Examples</strong>:</p>

<ul>
  <li>Weak passwords</li>
  <li>Program bug</li>
  <li>New employee doesn‚Äôt understand the security policy</li>
</ul>

<h2 id="threat">Threat</h2>

<blockquote>
  <p>A potential for violation of security, which exists when the attacker has the capability and intention to breach security</p>
</blockquote>

<p><em>Threat = capability x intent‚Äã</em></p>

<p><strong>Examples</strong></p>

<ul>
  <li>A hacker discovers a new way to exploit a vulnerability and writes a virus</li>
</ul>

<p>Evaluation models of threat (Microsoft STRIDE)</p>

<table>
  <thead>
    <tr>
      <th>Threat</th>
      <th>Security Aspect</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Spoofing</strong></td>
      <td>Authentication</td>
    </tr>
    <tr>
      <td><strong>Tampering</strong></td>
      <td>Integrity</td>
    </tr>
    <tr>
      <td><strong>Repudiation</strong></td>
      <td><a href="https://www.cryptomathic.com/products/authentication-signing/digital-signatures-faqs/what-is-non-repudiation">Non-repudiation</a> - the assurance that no one can deny the validity of something (data, service etc.)</td>
    </tr>
    <tr>
      <td><strong>Information disclosure</strong></td>
      <td>Confidentiality</td>
    </tr>
    <tr>
      <td><strong>Denial of Service</strong></td>
      <td>Availability</td>
    </tr>
    <tr>
      <td><strong>Elevation of Privilege</strong></td>
      <td>Authorisation</td>
    </tr>
  </tbody>
</table>

<h2 id="risk">Risk</h2>

<blockquote>
  <p>An expectation of loss expressed as the <strong>probability</strong> of an actual attack a threat will exploit a vulnerability with a harmful result.</p>
</blockquote>

<p><em>Risk = probability x harm = threat x vulnerability x harm</em></p>

<p><strong>Example</strong>:</p>

<ul>
  <li>Risk of your laptop being trampled by an escaped rhino is small</li>
  <li>Risk of leaving your laptop on the bus could be quite high.</li>
</ul>

<p>Here is a <a href="https://www.pilgrimsgroup.com/news.php?id=94">case study</a> for analysing the threat and risk.</p>

<h2 id="attack">Attack</h2>

<blockquote>
  <p>An assault on security that derives from a threat. A threat that has been realised</p>
</blockquote>

<p><strong>Active attack:</strong> Crashing a website through DOS</p>

<p><strong>Passive attack:</strong> Eavesdrop on the network traffic</p>

<p>Social engineering attack is another type of attack that just requires social skills, no technical skills.</p>

<h2 id="countermeasure">Countermeasure</h2>

<blockquote>
  <p>An action that reduces a threat, vulnerability, harm, or by eliminating or preventing the attack or by detecting the attack and reacting with corrective action. Anything that will reduce the violation of the security.</p>
</blockquote>

<p><strong>Examples:</strong></p>

<ul>
  <li>Prevention: firewall, passwords, encryption, backup, training staff etc.</li>
  <li>Detection: Intrusion detection system</li>
  <li>Reaction: Login systems that lock users out after 3 failed attempts.</li>
</ul>

<h2 id="trust">Trust</h2>

<blockquote>
  <p>‚ÄúIt is impossible to design a security system that is devoid of trust; we have to trust something. Even the person who writes his own security software has to trust his compiler and computer.‚Äù</p>

  <p><em>‚Äì Bruce Schneier, Secrets and Lies.</em></p>
</blockquote>

<p><strong>Trust is used in many contexts, trusted user, trusted third party, trusted host, trusted systems</strong></p>

<ul>
  <li>Security policy for trusted users will be different than other users</li>
  <li>Trust relationship limits our responsibility
    <ul>
      <li>When we design security mechanism/policy, we will think threat will not come from these trusted entities - so we do not need to think about how to defend against them</li>
    </ul>
  </li>
  <li>Affects our view of threat and thus the countermeasures we employ</li>
  <li>Trust is also a valuable business asset - it is something that a business would want to protect and maintain.</li>
</ul>

<h1 id="risk-analysis">Risk Analysis</h1>

<p><strong>Informal risk analysis.</strong></p>

<ul>
  <li>Identify (value) assets.</li>
  <li>Identify vulnerabilities</li>
  <li>Identify threats</li>
</ul>

<h2 id="qualitative-analysis">Qualitative analysis</h2>

<h3 id="checklist-method">Checklist Method</h3>

<p>Examples: the <strong>DREAD</strong> model by Microsoft:</p>

<p><strong>Damage</strong> - how bad would an attack be?</p>

<p><strong>Reproducibility</strong> - how easy is it to reproduce the attack?</p>

<p><strong>Exploitability</strong> - how easy is it to launch the attack?</p>

<p><strong>Affected users</strong> - how many people will be impacted?</p>

<p><strong>Discoverability</strong> - how easy is it to discover the threat?</p>

<h3 id="mathematical-method">Mathematical Method</h3>

<p>One example of a mathematical method of analysis is <strong>Fault Tree Analysis.</strong></p>

<p>You basically list the possible events that can occur , and list the possible causes of it ‚Äì until the most basic cause.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># If its listed it represents there is an OR relationship,</span>
<span class="c1"># otherwise an AND relationship is explicitly stated (last line)</span>
<span class="c1"># Usually, this is a drawn diagram but I'm lazy.</span>
<span class="s">Car Won't Start</span><span class="pi">:</span>
  <span class="na">Electrical Fault</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">Broken Wire</span>
    <span class="pi">-</span> <span class="s">Starter Faulty</span>
  <span class="na">Control Status</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">Foot on brake &amp; In Park</span>
</code></pre></div></div>

<p>This can only tell us the probability an attack will occur. Afterwards, we still have to determine the amount of harm that it will cause, and we will get some form of <strong>measurable risk</strong>.</p>

<h1 id="analysing-security-incidents">Analysing Security Incidents</h1>

<p>Key questions to ask are:</p>

<ul>
  <li>Who is doing it?</li>
  <li>Motivation</li>
  <li>What is the damage - which aspect of security is breached?
    <ul>
      <li>Not all about divulging secrets</li>
      <li>Also include DOS, integrity, reputation loss</li>
    </ul>
  </li>
  <li>What should system security encompass?
    <ul>
      <li>What elements can be considered to avoid the incident?</li>
    </ul>
  </li>
</ul>

<p><strong>Example of analysis. DoS ‚Äì Case study 2</strong></p>

<p>Who is doing it? - Russian government allegedly</p>

<p>Motivation? - Prevent criticism</p>

<p>What damage? - Availability</p>

<p>What should system security encompass? - Service provider should have resources available to serve genuine users.</p>

<p><strong>Example of analysis with terminology. Morris Worm.</strong></p>

<p><strong>The Case.</strong> 1988 - Robert Morris exploited a program bug to write a ‚Äúworm‚Äù.</p>

<ul>
  <li>Considered the first computer ‚Äúworm‚Äù on Internet</li>
  <li>Not intend to cause damage, but to measure the size of Internet</li>
  <li>Get into a computer through <strong>rsh</strong>*, generate a process and invoke the OS commands to obtain certain information about the network</li>
  <li>Gradually slow down the computer to be completely useless</li>
  <li>Computers on the network can be infected rapidly</li>
</ul>

<p><strong>Outcome.</strong> Rapidly infected 10% of all machines on the Arpanet. Caused the estimated damage of $100 million.</p>

<p><strong>Analysis.</strong></p>

<ul>
  <li>Asset: The computers on the Arpanet</li>
  <li>Vulnerability: rsh comment loophole in Unity OS</li>
  <li>Threat: Robert has the capability because he discovered the loophole. He had the intent because he wrote the program to make use of the loophole</li>
  <li>Attack: Robert ran the worm, and it replicated itself rapidly across the Arpanet</li>
  <li>Risk: (<em>probability x harm</em>) <em>(10% of all machines) x (Money loss)</em> because of computer slowdown.</li>
  <li>Countermeasure: Robert was charged in court. Applied security patch for the rsh loophole.</li>
</ul>

<h1 id="authentication">Authentication</h1>
       
        <h1 id="why-authentication">Why Authentication?</h1>

<p>The general intention of computer security is to prevent unauthorised access and to ensure authorised users can access systems quickly.</p>

<blockquote>
  <p>First step of control is to identify who a user is (Identification) and verify this identification (authentication)</p>

  <ul>
    <li>Identification: Identity by username</li>
    <li>Authentication: a process of verifying if the users are really who they claim they are</li>
  </ul>
</blockquote>

<h1 id="passwords">Passwords</h1>

<blockquote>
  <p>A basic but very useful authentication method</p>

  <ul>
    <li>
      <p>invaluable first line of security defence</p>
    </li>
    <li>
      <p>easy to use and implement</p>
    </li>
  </ul>
</blockquote>

<h2 id="the-problem-with-passwords">The Problem with Passwords</h2>

<ul>
  <li>Weak passwords (People set weak passwords)</li>
  <li>People often repeat passwords for different accounts</li>
  <li>Even if people have good password habits, some sites store passwords in plaintext</li>
  <li>Some sites allow unlimited login attempts</li>
  <li>Some sites/systems don‚Äôt salt passwords ‚Äì makes it easy to crack with computers.</li>
</ul>

<h3 id="peoples-tendency-in-setting-passwords">People‚Äôs tendency in setting passwords</h3>

<ul>
  <li>According to one survey, 12% of employees used ‚Äúpassword‚Äù as their password</li>
  <li>Password length is short</li>
  <li><strong>1/4</strong> of hashed passwords were cracked using a dictionary and combinations of the username.</li>
  <li>Around 12% use dictionary words</li>
  <li>81% use alphanumeric passwords</li>
</ul>

<h3 id="user-overload">User Overload</h3>

<ul>
  <li>On one hand, we should not set simple passwords but should set different passwords for different accounts</li>
  <li>On the other hand, we have many different accounts
    <ul>
      <li>Microsoft studied users‚Äô password behaviour
        <ul>
          <li>The average user has 25 password accounts</li>
          <li>But the average user has 6.5 different passwords.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<blockquote class="extra">
    Edmund shared an <a href="https://xkcd.com/936/">XKCD</a> the other day that summarises the problem with passwords.
</blockquote>

<h1 id="password-cracking">Password Cracking</h1>

<p>The time taken to crack a password with brute force depends on the number of combinations,
\(\text{Let length = L, and character set size = W} \\
Total \; Combinations= W^{L}\)</p>

<table class="centeredtable">
  <thead>
    <tr>
      <th>Password</th>
      <th>Combinations (C)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>26 characters - length 4</td>
      <td>26<sup>4</sup> = 456,976</td>
    </tr>
    <tr>
      <td>52 characters - length 4</td>
      <td>52<sup>4</sup> = 7.3 √ó¬†10<sup>6</sup></td>
    </tr>
    <tr>
      <td>94 characters - length 8</td>
      <td>94<sup>8</sup> = 6.1 √ó¬†10<sup>15</sup></td>
    </tr>
  </tbody>
</table>

<h2 id="cracking-speed">Cracking Speed</h2>

<p>Indicative speeds using current tools like <strong>hashcat</strong> or <strong>John the Ripper</strong></p>

<table class="centeredtable">
  <thead>
    <tr>
      <th>Hash</th>
      <th>Using</th>
      <th>Speed</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>MD5</td>
      <td>Good PC</td>
      <td>10<sup>7</sup> guess/second</td>
    </tr>
    <tr>
      <td>SHA256</td>
      <td>Good PC</td>
      <td>10<sup>6</sup> g/s</td>
    </tr>
    <tr>
      <td>MD5</td>
      <td>PC + Graphics Card</td>
      <td>10<sup>10</sup> g/s</td>
    </tr>
    <tr>
      <td>SHA256</td>
      <td>PC + Graphics Card</td>
      <td>10<sup>9</sup> g/s</td>
    </tr>
  </tbody>
</table>

<p>With a GPU cluster, passwords can be cracked even faster ‚Äì heavily depends on <strong>hardware</strong>.</p>

<p>Expected time to crack a password, \(Time = (Total\; Combinations)/Speed\)</p>

<h2 id="password-strength">Password Strength</h2>

<p>Often expressed as an entropy value, <em>x</em> ‚Äì the number of bits needed to represent W<sup>L</sup>.</p>

<p>Therefore, \(x = log_2W^L\).</p>

<p><strong>Examples</strong>:</p>

\[Entropy = 2 \times log_226 \approx 2 \times 4.7 = 9\]

\[Entropy = 4 \times log_252 \approx 4\times 5.7 = 22.8\]

<h3 id="human-generated-passwords">Human Generated Passwords</h3>

<p>While entropy measures the ‚Äúuncertainty‚Äù of a password - it is the maximum level of uncertainty. However, humans don‚Äôt choose random passwords; they use words or a pattern of characters - much less uncertainty in user-generated password. This leads to some reasons behind certain password cracking techniques like look-up tables, which we will look at in the next chapter.</p>

<h2 id="password-hashing">Password Hashing</h2>

<p>We should never store passwords in plaintext. Instead we store the hash:</p>

<ul>
  <li>Hash is generated by a one-way hash function</li>
  <li>Hash function produces a fixed length hash value from the input</li>
  <li>Hashes are not meant to be reversible. Easy to compute f(x) but very hard to compute x from f(x).
    <ul>
      <li>If the input changes by even a bit - the resulting hash should be completely different</li>
      <li>Hash function types: MD5, SHA256, SHA512 etc‚Ä¶</li>
    </ul>
  </li>
</ul>

<h1 id="other-authentication-methods">Other Authentication Methods</h1>

<p>Passwords are just one way of providing authentication, what other methods are there?</p>

<p><strong>Biometrics.</strong> Does not have a clear cut yes or no - there is room for false negatives or even false positives (which are worse).</p>

<p>Here are some statistics on the various  non-password authentication methods</p>

<table class="centeredtable">
  <thead>
    <tr>
      <th>¬†</th>
      <th>False Pos</th>
      <th>False Negative</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Biometric</td>
      <td>1%</td>
      <td>10%</td>
    </tr>
    <tr>
      <td>Face</td>
      <td>1%</td>
      <td>0.1%</td>
    </tr>
    <tr>
      <td>Fingerprint</td>
      <td>2%</td>
      <td>0.1%</td>
    </tr>
    <tr>
      <td>Hand Geometry</td>
      <td>0.94%</td>
      <td>0.99%</td>
    </tr>
    <tr>
      <td>Iris</td>
      <td>0.0001%</td>
      <td>0.2%</td>
    </tr>
    <tr>
      <td>Keystrokes</td>
      <td>7%</td>
      <td>0.1%</td>
    </tr>
    <tr>
      <td>Voices</td>
      <td>2%</td>
      <td>10%</td>
    </tr>
  </tbody>
</table>
<h1 id="password-cracking">Password Cracking</h1>
       
        <h1 id="methods">Methods</h1>

<p>There are a few different methods for cracking a password hash:</p>

<ul>
  <li>Brute force attack - not the most efficient approach</li>
  <li>Dictionary attack - tries likely words, short passwords, dictionary lookup. Is likely to have a good chance of success on many systems.</li>
  <li>Look-up tables - precomputes the hash values of a large number of passwords.</li>
  <li>Reverse Look-up tables - uses hash chains to reduce the storage space</li>
  <li>Rainbow tables - an improvement on look-up tables as it reduces chain collisions</li>
</ul>

<p>We will go through each method</p>

<h1 id="brute-force-and-dictionary-attacks">Brute Force and Dictionary Attacks</h1>

<p>The simplest way to crack a hash, here are the steps/outline:</p>

<ol>
  <li>Guess password</li>
  <li>Hash the guess</li>
  <li>Check if the guess‚Äô hash equals the given hash</li>
  <li>If the hashes are equal, the guess is the password.</li>
  <li>If not go back to step 1.</li>
</ol>

<p>As you can tell this is the slowest method but easiest to implement.</p>

<h2 id="brute-force-attacks">Brute Force Attacks</h2>

<ul>
  <li>try every possible combination of characters</li>
  <li>very computationally expensive, the least efficient</li>
  <li>will eventually find the password after a long time (longer if passwords are more complex and longer)</li>
</ul>

<h2 id="dictionary-attacks">Dictionary attacks</h2>

<ul>
  <li>Uses a file containing words, phrases, common passwords, and other string that are likely to be used as a password</li>
  <li>Theses dictionary files are constructed by extracting words from large bodies of text, and even from real databases of passwords.</li>
  <li>Further processing is often applied to dictionary files, such as replacing words with their ‚Äúleet speak: equivalents (hello = h3110)</li>
</ul>

<h1 id="lookup-tables">Lookup Tables</h1>

<p>In Brute force/dictionary cracking a password is hashed every single time before being guessed.</p>

<p>What look-up tables do is that it pre-computes the hashes of the passwords, store the hashes and the corresponding passwords in a look-up table.</p>

<p>When given a hash, it looks up the table for the matching password - basically dictionary but precomputes hashes. More efficient.</p>

<h1 id="reverse-lookup-tables">Reverse Lookup Tables</h1>

<p>Problem with Dictionary Attack and Lookup Tables</p>

<ul>
  <li>Stores all password possibilities in a large database</li>
  <li>Not efficient for long passwords (too much storage)</li>
</ul>

<p>What Reverse Lookup Tables do</p>

<ul>
  <li>sacrifice time for storage</li>
  <li>works better for long passwords</li>
</ul>

<p>Does this using a technique called <strong>hash chain</strong>.</p>

<h2 id="hash-chain">Hash Chain</h2>

<p>Firstly, we have to define a <strong>reduction function</strong>, <strong><em>R</em></strong>, that maps hash values back into <strong>a</strong> password, <strong>not</strong> the original password (it isn‚Äôt an inverse of the hash function) but just some other password that fits a certain criteria.</p>

<p>This criteria is that the password must belong to a domain in <strong><em>P</em></strong> where it is the set of all combinations of length <strong><em>L</em></strong> characters in a character set <strong><em>W</em></strong>. Example, if we want to crack all passwords of length 5, consisting of the characters from the character set [ABC‚Ä¶XYZ0123456789], then <strong><em>P</em></strong> is the set of all combinations of 5 characters from this character set.</p>

<blockquote>
  <p>The <strong>only requirement</strong> for reduction function is to return a value in P, other than that it can be anything.</p>
</blockquote>

<p>Let‚Äôs say our starting password is ‚Äúrandom‚Äù. We hash it with the hash function that we are targeting, so MD5, SHA256, etc., then we reduce the hash with <strong><em>R</em></strong>. We do this as many times as we want (this is usually a calculated amount based on how long we expect/want to spend).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hash: "random"                           -&gt; "7ddf32e17a6ac5ce04a8ecbf782ca509"
R:    "7ddf32e17a6ac5ce04a8ecbf782ca509" -&gt; "ienw3"
Hash: "ienw3"                            -&gt; "b9322e367ad002d5adf7ca60b8b61e86"
      ... (1000 times) ...
Hash: "o1gti"                            -&gt; "27aa4cbd3653a4617e0aec76ba3af9a4"
</code></pre></div></div>

<h3 id="how-rlt-saves-space">How RLT saves space</h3>

<p>Many passwords and hashes are generated in the hash chain, but because we have the R function and H function we <strong>only store</strong> the <em>start</em> and <em>end</em> passwords (lecture notes). Some sources online say that the start <strong>password</strong> and the end <strong>hash</strong> is stored.</p>

<p>To use this table, lets say we have an input hash taken from a compromised user password database ‚Äúb9322e367ad002d5adf7ca60b8b61e86‚Äù. If we stored the end hash, then what we can do is to first check if this password exists in the table ‚Äì meaning we are extra lucky and we save loads of time.</p>

<p>Otherwise, if it doesn‚Äôt exist or we use the system of storing end passwords (because the probability of finding the end hash immediately is very low) we do the following</p>

<ol>
  <li>Apply the <strong><em>R</em></strong> function on hashes and <strong><em>H</em></strong> function on passwords.</li>
  <li>Check if the resultant password/hash (depending on which system you use) exists in the table.</li>
  <li>Repeat from step 1 until a set limit <strong><em>N</em></strong> (i.e 1000) or until we find a <strong>match</strong>.</li>
</ol>

\[h-(R)\rightarrow p'1 -(H)\rightarrow h'1 -(R)\rightarrow p'2 -(H)\rightarrow \ldots\]

<p>If at any point we observe a match:</p>

<ul>
  <li>We can get the corresponding start password (from the look-up table) and use it to recreate the chain</li>
  <li>There is a good chance that the chain will contain the given hash <em>h</em></li>
  <li>If so, the password immediately preceding <em>h</em> in the chain is the matching password</li>
</ul>

<h3 id="false-alarms">False Alarms</h3>

<p>The reduction function we have defined does not represent a 1 to 1 relation between the hash and the password ‚Äì 2 different hashes when going through the (<strong><em>R</em></strong>) may give the same output.</p>

<blockquote>
  <p>This is the <strong>main problem</strong> with RLT ‚Äì hash chain collisions that we call false alarms.</p>
</blockquote>

<p><strong>Example.</strong> Both following chains contains p2; all info after p2 in both chains will be the same</p>

<p><em>Chain 1: p1-&gt; h1 -&gt; p2 -&gt; h2 -&gt; p3 -&gt; h3 -&gt; p4</em></p>

<p>Chain 2: p‚Äô1 -&gt; h‚Äô1 -&gt; p‚Äô2 -&gt; h‚Äô2 -&gt; p2 -&gt; h2 -&gt; p3*</p>

<p>Chain collision wastes space for the attacker</p>
<ul>
  <li>this is because after a certain $p_n$all following passwords in both chains will be the same</li>
  <li>if this chain was in the 10,000, a majority will be the same (wastes space!)</li>
</ul>

<h1 id="rainbow-table">Rainbow Table</h1>

<blockquote>
  <p>Rainbow tables are designed to <strong>reduce</strong> chain collisions or false alarms. It does this by using <strong>different R functions</strong> in different reduction stages when generating the hash chain to reduce the probability of chain collisions.</p>
</blockquote>

<p>The collision between chain 1 and chain 2 is reduced.</p>

<p><em>Chain 1: p1 -&gt; h1 ‚Äì(R1)-&gt; p2 -&gt; h2 ‚Äì(R2)-&gt; p3 -&gt; h3 ‚Äì(R3)-&gt;p4</em></p>

<p><em>Chain 2: p‚Äô1 -&gt; h‚Äô1 ‚Äì(R1)-&gt; p‚Äô2 -&gt; h‚Äô2 ‚Äì(R2)-&gt; p‚Äô‚Äô2 ‚Äì&gt; h‚Äô‚Äô2 ‚Äì(R3)-&gt; p‚Äô3</em></p>

<h2 id="cracking-passwords-in-rainbow-table">Cracking passwords in Rainbow Table</h2>

<p>Given a hash, $h$, the reduction functions must be applied in the right order when creating the chain.</p>

<p>Lets say we have $k$ reduction functions, anyone of them can be applied first to the given hash.</p>

<p>Assume $R_k$ is first applied to the given hash:</p>

<p>The order of R functions applied is: \(h \;‚Äì(R_k)\rightarrow p‚Äô1 ‚Äì(R_1)\rightarrow ‚Ä¶ ‚Äì(R_2)\rightarrow, ‚Ä¶, ‚Äì(R_{k-1})\rightarrow ‚Ä¶\)</p>

<p>If password not found, means $R_k$ was not the first R function to be applied. Proceed to assume $R_{k‚àí1} $is first applied.</p>

\[R_{k-1}, R_k, R_1, ‚Ä¶, R_{k-2}\]

<p>If password not found, continue so on and so forth, until finally $R_1 $is first applied:</p>

\[R_1, R_2, R_3, ‚Ä¶, R_{k-1}, R_k\]

<p>If the password still cannot be found after this, we say that the password of the given hash is not embedded in the rainbow table, and we are not able to find it.</p>

<h1 id="defence">Defence</h1>

<p>There is no way to prevent brute-force or dictionary attacks.</p>

<p>But we can use <strong>password salts</strong> to make lookup table, reverse lookup and rainbow tables attacks less effective.</p>

<h2 id="password-salt">Password Salt</h2>

<p>Salt is a randomly generated number. The salt and the password are connected and used by the hash function to generate hash:
\(h = Hash(password+salt)\)
<strong>Both</strong> <strong><em>h</em></strong>‚Äã and the corresponding <strong>salt</strong> are stored in the password file</p>

<p>When a user enters a password during the login</p>

<ul>
  <li>Obtain the <strong>salt</strong> value used to generate the hash for the user</li>
  <li>Connect the input password with the <strong>salt</strong>‚Äã</li>
  <li>Generate the hash of this input and compare it with the stored hash.</li>
</ul>

<h3 id="how-does-salt-help-defend-against-table-attacks">How does salt help defend against table attacks?</h3>

<p>In order for the lookup table attack to succeed, an attacker needs to precompute the tables</p>

<p>Since <strong>salt</strong> is used, we precompute and store the hash of a password for each possible <em>salt</em> value, which increases the possible combination of passwords + salts that we have to pre-compute in our lookup tables <strong>a lot</strong>.</p>

<p>For password p, precompute and store:
\(Hash(p+salt_1), Hash(p+salt_2),..., Hash(p+salt_n)\)
When the <strong>salt</strong> is large (e.g. 48bits), the required storage space will be too big for the attack to be worthwhile. In order to precompute reverse and rainbow tables, an attacker needs to generate a chain for a password and each possible <em>salt</em>.</p>

<ul>
  <li>Because <strong>salt</strong> is not user generated - makes it more unpredictable as well.</li>
</ul>

<h1 id="how-are-hashes-stored-in-linux">How are hashes stored in Linux?</h1>

<blockquote>
  <p><strong>TLDR.</strong> When a user is created their info is stored in the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file and their hash + salt is stored in the <code class="language-plaintext highlighter-rouge">etc/shadow</code> file. Only the user can read <code class="language-plaintext highlighter-rouge">passwd</code> and only root can read <code class="language-plaintext highlighter-rouge">shadow</code>.</p>
</blockquote>

<p>It is likely that you won‚Äôt need the below information for your exam, they were from my notes mainly for the coursework but I thought I‚Äôd put it up anyways.</p>

<p>When you create a new user in Linux, Linux creates an entry in the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> and the <code class="language-plaintext highlighter-rouge">/etc/shadow</code> files:</p>

<p><strong>Entry in <code class="language-plaintext highlighter-rouge">/etc/passwd</code></strong></p>

<p>This file can be read by an user. The entry created in passwd file, it contains a number of fields which are separated by colon (:).</p>

<p><img src="part3.assets/image-20201210213226777.png" alt="image-20201210213226777" /></p>

<ol>
  <li>Username - used when user logs in.</li>
  <li>Meant for storing ha but hash is typically not stored in /etc/passwd, but in the file /etc/shadow. An <em>x</em> character indicates that the hash is stored in <code class="language-plaintext highlighter-rouge">/etc/shadow</code>.</li>
  <li>User ID (UID) - UID 0 is reserved for root and UIDs 1-99 are reserved for other predefined accounts. Further UID 100-999 are reserved by system for administrative and system accounts/groups.</li>
  <li>Group ID (GID) - The primary group ID (stored in <code class="language-plaintext highlighter-rouge">/etc/group</code> file)</li>
  <li>General Info on User - The comment field. It allows you to add extra information about the users such as user‚Äôs full name, phone number etc. This field is used by <code class="language-plaintext highlighter-rouge">finger </code>command</li>
  <li>Home directory - The absolute path to the directory the user will be in when they log in. If this directory does not exist then user‚Äôs directory becomes <code class="language-plaintext highlighter-rouge">/</code></li>
  <li>Command/shell - The absolute path of a command or shell (<code class="language-plaintext highlighter-rouge">/bin/bash</code>). Typically, this is a shell. Please note that it does note have to be a shell. For e.g., <code class="language-plaintext highlighter-rouge">sysadmin</code> can use the <code class="language-plaintext highlighter-rouge">nologin</code> shell, which acts as a replacement shell for the user accounts. If shell is set to <code class="language-plaintext highlighter-rouge">/sbin/nologin</code> and the user tries to log in to the Linux system directly, the <code class="language-plaintext highlighter-rouge">/sbin/nologin</code> shell closes the connection.</li>
</ol>

<p><strong>Entry in <code class="language-plaintext highlighter-rouge">/etc/shadow</code></strong></p>

<p>Shadow can only be read by root user. This is how the hash looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$6$JVGtK2Il$/s.5q4M1WN/ekw2rM26OHId9TPELOcPMmHG.E7zCzSbalzVPgPPGUIB7f7/2mTfj/Lg3RgoKhAkcsBDkJGAN.1:18554:0:99999:7:::
</code></pre></div></div>

<p>If the hash is a <code class="language-plaintext highlighter-rouge">*</code> - means that the account is disabled.</p>

<p><code class="language-plaintext highlighter-rouge">!</code> or <code class="language-plaintext highlighter-rouge">!!</code> means that the account is locked</p>

<p>A blank entry means that a password is not required to log in.</p>

<p>The number between 1st 2 dollar signs represents the hash function used by the OS - here 6 represents SHA512.</p>

<p>The characters between the 2nd and 3rd dollar sign is the <em>salt</em>.</p>

<p>All the subsequent bits up till the colon (:) - is the generated <em>hash</em> for the password</p>

<p>Last part (after the colon)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>:18554:0:99999:7:::
</code></pre></div></div>

<ol>
  <li>The time the password was generated</li>
  <li>The minimum number of days between authorised password changes. If we set it to be 0, password can be changed immediately. If we set it to 7, we have to use password for 7 days.</li>
  <li>The maximum number of days a password can last for (compulsory to change after the set number of days)</li>
  <li>The number of days in advance the system will give you a warning to change password</li>
</ol>

<h2 id="unix-password-protection">Unix password protection</h2>

<p>Unix system may set the local rules for setting passwords.  For example, it can set the length that password must have, number of upper or lower cases, or even symbols.</p>

<ul>
  <li>Time before password can be changed or must be changed</li>
  <li>Salt used (pseudo-random)</li>
  <li>Type of Hash can be changed as well</li>
</ul>

<p>These are all ways Unix tries to protect passwords.</p>
<h1 id="cryptography">Cryptography</h1>
       
        <p>Some terminology</p>

<ul>
  <li>Plaintext - original message</li>
  <li>Ciphertext - the result of encrypting the message</li>
  <li>Encryption/decryption - process of transforming plaintext to ciphertext (or reverse)</li>
</ul>

<h1 id="different-types-of-encryption">Different types of encryption</h1>

<p><strong>Secret key</strong>:</p>

<ul>
  <li>The key is a secret, only known to the communicating parties</li>
  <li>The same key is used for encryption and decryption</li>
</ul>

<p><strong>Public key:</strong></p>

<ul>
  <li>Use a key to encrypt the message</li>
  <li>This encryption key can be publicly  known</li>
  <li>User another key to decrypt the message</li>
  <li>The decryption key is kept private</li>
  <li>Clever maths are used</li>
</ul>

<h1 id="encryption-technique-properties">Encryption Technique Properties</h1>

<p>Good encryption techniques should have 4 properties</p>

<ol>
  <li>
    <p>Confusion</p>

    <ul>
      <li>If we change a bit/a letter of they <strong>key</strong>, multiple parts of the ciphertext will change</li>
      <li>hide the relationship between ciphertext and key</li>
    </ul>
  </li>
  <li>
    <p>Diffusion</p>

    <ul>
      <li>If we change a bit/a letter of the <strong>plaintext</strong>, then half of bits of the ciphertext should change</li>
      <li>Spread the statistical structure of plaintext over multiple parts of the ciphertext</li>
      <li>hide the relation between plaintext and ciphertext</li>
    </ul>
  </li>
  <li>
    <p>Cipher text is hard to break even with the most generous assumptions</p>

    <ul>
      <li>Know the encryption process</li>
      <li>know the initial settings (e.g. key length, block length)</li>
      <li>as long as the key is secret the ciphertext is still secure</li>
    </ul>
  </li>
  <li>
    <p>Management of the encryption scheme must be feasible and cost-effective</p>

    <ul>
      <li>Long key may be very secure - but how can it be manged?</li>
    </ul>
  </li>
</ol>

<h1 id="secret-key-encryption">Secret key encryption</h1>

<p>Also known as symmetric key, shared key, single key encryption.</p>

<p>Modern ‚Äústandard algorithm‚Äù:</p>

<ul>
  <li>First was the Data Encryption Standard (DES)</li>
  <li>then the Advanced Encryption Standard (AES)</li>
</ul>

<p><strong>How it works.</strong></p>

<ol>
  <li>A secret key is shared by sender and receiver.</li>
  <li>This secret key is used together with a known pubic algorithm (like AES)</li>
  <li>The ciphertext is transmitted</li>
  <li>The receivers decrypt the ciphertext with the known algorithm and the secret key to get plaintext.</li>
</ol>

<h1 id="techniques-of-encryption">Techniques of Encryption</h1>

<p>There are many different encryption techniques, some better than others.</p>

<h2 id="steganography">Steganography</h2>

<blockquote>
  <p>Steganography is a means of hiding an encrypted message.</p>

  <ul>
    <li>Often when an encrypted message is sent, it is suspicious because it is unreadable.</li>
    <li>Steganography is used to hide the encrypted message in something unsuspicious.</li>
  </ul>
</blockquote>

<p><strong>Steganographic Process</strong></p>

<p><em>(cover medium) + (hidden data) + (stegano key) = stegano medium</em></p>

<ul>
  <li><strong>cover medium</strong>: the file in which we will hide the hidden_data</li>
  <li><strong>hidden data</strong>: may be encrypted using stegano key or another key</li>
  <li><strong>stegano medium</strong>: is the file we send.</li>
</ul>

<p>The <strong>cover medium</strong> (and thus <strong>stegano medium</strong>) are typically image or audio files.</p>

<h3 id="hiding-data-in-an-image">Hiding data in an image</h3>

<p>Images typically used either 8-bit or 24-bit colour</p>

<p>Lets take 24-bit colour as an example:</p>

<ul>
  <li>Each pixel is represented by three bytes</li>
  <li>Each of the three bytes representing the intensity of the three primary colours red, green, blue (RGB)</li>
</ul>

<p>Using Least Significant Bit (LSB) insertion - we can hide data in the image.</p>

<h4 id="lsb-insertion">LSB Insertion</h4>

<p>Uses binary representation of the <em>hidden_data</em> to overwrite the LSB of each byte in the <em>cover_image</em></p>

<p>If we are using 24-bit colour, the amount of change will be minimal and indiscernible to the human eye.</p>

<p><strong>Example.</strong></p>

<p>Given three pixels:</p>

<ol>
  <li>10010101 00001101 11001001</li>
  <li>10010110 00001111 11001010</li>
  <li>1001111 00010000 11001011</li>
</ol>

<p>We can hide the 9 bits of data in the above three pixels:</p>

<ol>
  <li>1001010<strong>1</strong> 0000110<strong>0</strong> 1100100<strong>1</strong></li>
  <li>1001011<strong>1</strong> 0000111<strong>0</strong> 1100101<strong>1</strong></li>
  <li>1001111<strong>1</strong> 0001000<strong>0</strong> 1100101<strong>1</strong></li>
</ol>

<p>Hidden message is: <strong>101101101</strong></p>

<h2 id="code-words">Code Words</h2>

<p>Define code for each vocabulary in a code book which is like a dictionary. You lookup the dictionary to decipher the code word.</p>

<h2 id="transpositionpermutation-cipher">Transposition/Permutation Cipher</h2>

<p><strong><em>Confusion</em></strong></p>

<p>Re-arrange plaintext into columns/rows of a fixed length and then send the message read the other way</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Plaintext</span><span class="pi">:</span>  <span class="s">HISECRETMESSAGE</span>
<span class="na">Rearrange</span><span class="pi">:</span>  <span class="s">H E E E A</span>
            <span class="s">I C T S G</span>
            <span class="s">S R M S E</span>
<span class="na">Ciphertext</span><span class="pi">:</span> <span class="s">HEEEAICTSGSRMSE</span>
</code></pre></div></div>

<p>Letters are the same, but in a different order. The <strong>shared secret</strong> is knowing what permutation is carried out. This rearrangement can be done any number of times.</p>

<p>A more <strong>confusing</strong> version of this is double transposition, where your rearranged plaintext uses a code word and a number to decide how the text should be rearranged further. In the example below, we have rearrange the grid of letters from the first round according to the numbers specified (if there are not enough letters in the column to fill the row, you just continue with the next column).</p>

<pre><code class="language-YAML">Codeword: C A K E S         C A K E S
Number:   2 5 1 4 3         2 5 1 4 3
          H E E E A ------&gt; E T M H I
          I C T S G         S A G E E
          S R M S E         S S E C R
</code></pre>

<h2 id="monoalphabetic-substitution-cipher">Monoalphabetic Substitution Cipher</h2>

<p><strong><em>Confusion</em></strong></p>

<p>If you are familiar with the caesar cipher ‚Äì this is it. Basically have a ciphertext alphabet, where each symbol maps to the normal alphabet.</p>

<blockquote>
  <p><strong>Not the best</strong> technique because there is a <strong>linear relation</strong> between the letters/symbols and attackers can easily figure out the encryption key.</p>
</blockquote>

<p><em>Supposed A ‚Ä¶ Z = 0 ‚Ä¶ 25, then y = x + a mod 26 (a is the encryption key)</em></p>

<p><strong>Another way</strong> is to use a keyword e.g. ‚Äúzebras‚Äù</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Plaintext alphabet</span><span class="pi">:</span>  <span class="s">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
<span class="na">Ciphertext alphabet</span><span class="pi">:</span> <span class="s">ZEBRASCDFGHIJKLMNOPQTUVWXY</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Disadvantage.</strong> There is no ‚Äúlinear relation‚Äù but a long ciphertext can be easily cracked by <strong>frequency analysis</strong>.</p>
</blockquote>

<p><strong>Frequency analysis</strong> relies on the fact that some letters are used more than others. By counting the letter frequency of a certain symbol in the ciphertext, someone can make an intelligent guess on which letter in the alphabet it represents.</p>

<p>To prevent this, multiple ciphertext alphabets are used‚Ä¶</p>

<h2 id="polyalphabetic-substitution-cipher">Polyalphabetic Substitution Cipher</h2>

<p><strong><em>Confusion</em></strong></p>

<p>A key is used to decide which ciphertext alphabet is applied in each substitution. An example is the Vigenere cipher. Here is table that works together with the vignere cipher.</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>A</th>
      <th>B</th>
      <th>‚Ä¶</th>
      <th>Y</th>
      <th>Z</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>A</strong></td>
      <td>A</td>
      <td>B</td>
      <td>‚Ä¶</td>
      <td>Y</td>
      <td>Z</td>
    </tr>
    <tr>
      <td><strong>B</strong></td>
      <td>B</td>
      <td>C</td>
      <td>‚Ä¶</td>
      <td>Z</td>
      <td>A</td>
    </tr>
    <tr>
      <td><strong>‚Ä¶</strong></td>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
      <td>‚Ä¶</td>
    </tr>
    <tr>
      <td><strong>Y</strong></td>
      <td>Y</td>
      <td>Z</td>
      <td>‚Ä¶</td>
      <td>W</td>
      <td>X</td>
    </tr>
    <tr>
      <td><strong>Z</strong></td>
      <td>Z</td>
      <td>A</td>
      <td>‚Ä¶</td>
      <td>X</td>
      <td>Y</td>
    </tr>
  </tbody>
</table>

<p>Using this table, and a secret key: <strong>abattis</strong> ‚Äì we check the cell that corresponds to the pair (Plaintext_letter)(Key_symbol) = Ciphertext Symbol</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">Plaintext</span><span class="pi">:</span>  <span class="s">EXAMPLE</span>
<span class="na">Keystream</span><span class="pi">:</span>  <span class="s">abattis</span>
<span class="na">Ciphertext</span><span class="pi">:</span> <span class="s">EYAFITW</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Disadvantage.</strong> Still has the same statistical flaw for the letters that use the same key alphabet. This can be mitigated by using a longer keyword and is the most secure (in theory) if the key is the same length as the plaintext.</p>
</blockquote>

<h2 id="one-time-pad">One time pad</h2>

<p>This is where each letter in the message is encrypted with a different alphabet set. This is as secure as you can get but the <strong>problem</strong> lies with how the key is <strong>shared</strong> as both parties have to know the key which is as long as the plaintext.</p>

<blockquote>
  <p><strong>Disadvantage.</strong> As a result, one time pad is not a practical solution because of key generation, key distribution, key protection.</p>
</blockquote>

<h2 id="combining-message-and-key">Combining message and key</h2>

<p>In a computer, <strong>plaintext</strong> and the <strong>key</strong> are an arrangement of bits. The best way to combine them is to use bitwise <strong>XOR</strong>.</p>

<ul>
  <li>Bitwise operations are not as computationally expensive as addition operations. (If you study 132, 1 just needs a logic gate, the other needs an entire adder/subtractor).</li>
  <li><strong>AND</strong> and <strong>OR</strong> are not good as they do not produce unique encryption ‚Äì so they are not good for decryption.</li>
</ul>

<p><strong>XOR</strong> on the other hand produces a unique encryption - using XOR, ciphertext can be decrypted by performing XOR over ciphertext and key. So it is very easy to encrypt and to decrypt, you just need the <strong>key</strong>.</p>

<h1 id="data-encryption-standard-des">Data Encryption Standard (DES)</h1>

<p><em>The first standardised encryption method. Is based on the Feistal approach.</em></p>

<ul>
  <li>Uses block cipher: 64-bit plaintext block size.</li>
  <li>Uses a 56-bit secret key (technically 64-bit, but the 8th bit of each 8-bits are parity bits which are dropped after the permutated choice 1)</li>
  <li>Goes through 16 rounds of encryption operations per block</li>
  <li>Uses substitution (confusion)</li>
  <li>Uses permutation (diffusion)</li>
  <li>Encryption operations are all public - but it is still hard to crack because the <strong>secret key</strong> is safe.</li>
</ul>

<blockquote>
  <p><strong>Block Cipher.</strong> Encrypts blocks of data one a time (DES)</p>

  <p><strong>Stream Cipher.</strong> Encrypts each input element (bit or byte etc.) one at a time, producing the machine output element as the process goes along.</p>
</blockquote>

<h2 id="fiestal-approach-overview">Fiestal Approach Overview</h2>

<figure align="center">
    <img src="https://upload.wikimedia.org/wikipedia/commons/f/fa/Feistel_cipher_diagram_en.svg" style="width:328px;height:480px;" class="center" />
        <figcaption style="text-align:center;">Fiestal Cipher Diagram, <a href="https://commons.wikimedia.org/wiki/File:Feistel_cipher_diagram_en.svg">Wikimedia Commons</a></figcaption>
</figure>

<ol>
  <li>Plaintext block is split into two equal parts (L<sub>0</sub> and R<sub>0</sub>), each of 32 bits.</li>
  <li>Run one side of  (i.e R<sub>0</sub>) through a round function that is fed a key, K<sub>0</sub>.</li>
  <li>The output of the function, R<sub>0</sub>K<sub>0</sub>, is <strong>XORed</strong> with the other half (L<sub>0</sub>).</li>
  <li>The output of this <strong>XOR</strong> is used as the input for the round function of the <strong>next round</strong>, while the initial R<sub>0</sub> will be <strong>XORed</strong> with this 2nd round function output.</li>
  <li>This continues for a total of 16 rounds, where the final blocks are the ciphertext.</li>
</ol>

<blockquote>
  <p>A characteristic of all <strong>Feistel ciphers</strong> is that the process for <strong>decryption</strong> follows the exact same steps as encryption ‚Äì <strong>only thing</strong> is that the round keys need to be used in the reverse order.</p>
</blockquote>

<p>Each round this is computed:
\(L_{i+1} = R_i, \; R_{i+1} = L_i \oplus F(R_i,K_i)\)</p>

<h2 id="the-round-function">The Round Function</h2>

<p>There are 4 operations in the function</p>

<ol>
  <li><strong>Expansion</strong>
    <ul>
      <li>32 bits half-block is expanded to 48 bits by duplicating half of the bits
        <ul>
          <li>32 bits organised into 8 pieces each with 4 bits</li>
          <li>Duplicate the first and fourth bit in each piece</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Key Combination</strong>
    <ul>
      <li>The output of the expansion is EX-OR with the current round key, K<sub>i</sub></li>
    </ul>
  </li>
  <li><strong>Substitution</strong>
    <ul>
      <li>The result of the EX-OR is broken into 8 6-bit pieces and each is passed through a unique substitution box or S-Box</li>
      <li>This uses the vectorial boolean function to convert 6-bit input to a 4-bit output
        <ul>
          <li>There is a lookup table to store the mapping from 6-bit input to 4-bit output</li>
          <li>E.g. <strong>1</strong>0110<strong>0</strong>. The bits in bold is the row name and the bits in between is the column. The cells in the lookup table specify the final substitution value that becomes the output. Refer to the table below.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Permutation</strong>
    <ul>
      <li>The result of that is passed through a permutation function P (diffusion)</li>
    </ul>
  </li>
</ol>

<p>In each row, the lookup table cell values will are unique ‚Äì meaning row-wise the values are from 0-16 (because 2<sup>4</sup> bits) but is not in order.</p>

<table>
  <thead>
    <tr>
      <th>¬†</th>
      <th>-0000-</th>
      <th>‚Ä¶</th>
      <th>-1111-</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0xxxx0</td>
      <td>14</td>
      <td>‚Ä¶</td>
      <td>7</td>
    </tr>
    <tr>
      <td>0xxxx1</td>
      <td>0</td>
      <td>‚Ä¶</td>
      <td>8</td>
    </tr>
    <tr>
      <td>1xxxx0</td>
      <td>4</td>
      <td>‚Ä¶</td>
      <td>0</td>
    </tr>
    <tr>
      <td>1xxxx1</td>
      <td>15</td>
      <td>‚Ä¶</td>
      <td>13</td>
    </tr>
  </tbody>
</table>

<h2 id="subkey-generation-key-schedule">Subkey Generation (Key Schedule)</h2>

<p>We said that the DES takes 1 64-bit key, but from the <a href="#fiestal-approach-overview">Feistal Diagram</a> above we see that each round function takes a different key ‚Äì this is because subkeys are generated with permutation functions.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/06/DES-key-schedule.png" class="center" /></p>

<h3 id="permuted-choice-1">Permuted Choice 1</h3>

<p>This function has 2 purposes:</p>

<ol>
  <li>To drop the 8th bit of each of the eight 8-bit blocks, as they are the parity bits</li>
  <li>Permute the remaining bits (56)</li>
</ol>

<p>After PC1 is done, the generation of the DES round keys (keys for each round function): In each round</p>

<ol>
  <li>The key is split into two 28-bit halves.</li>
  <li>Each half is shifted left by a set amount that may vary per round but will always be the same for encryption or decryption.</li>
  <li>The shifted halves are permuted with PC2 ‚Äì shuffle and select 48-bits from 56-bits (28 √ó 2)</li>
  <li>The shifted halves are also transferred to the next round where they are shifted again (the shifts are cumulative).</li>
</ol>

<h3 id="permuted-choice-2">Permuted Choice 2</h3>

<p>As mentioned above, the algorithm takes a 56-bit subkey as input and produces a 48-bit round key for each round function.</p>

<blockquote class="extra">
    <b>FYI.</b> Each bit of the initial 56-bit key is used in an average of 14 of 16 round keys.
</blockquote>

<h1 id="advanced-encryption-standard-aes">Advanced Encryption Standard (AES)</h1>

<p>The DES is now considered to be insecure due to the short key ‚Äì it has been broken by brute-force methods.</p>

<p>The <strong>AES</strong> is chosen as the new standard. Compared to DES it has a longer block size (128-bits), longer key (variable: 128, 192, or 256 bits) and faster implementation (only uses 1 S-box, while DES uses 8 distinct ones)</p>

<p>Similar block cipher features but uses a substitution-permutation network (SPN) ‚Äì <strong>mainly operations over matrices</strong> which is designed for more <strong>inherent parallelism</strong> and hence <strong>faster</strong>.</p>

<h2 id="sub-operations">Sub-Operations</h2>

<p>Encryption in AES uses 4 main operations. In the main rounds (not every round but most rounds) of encryption they are applied in the following order:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input -&gt; SubBytes -&gt; ShiftRows -&gt; MixColumns -&gt; AddRoundKey -&gt; ouput
</code></pre></div></div>

<p>There are additional details, like the key scheduler for AES, which are not covered in the lectures and further reading can be done <a href="https://www.commonlounge.com/discussion/e32fdd267aaa4240a4464723bc74d0a5">here</a>. <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard#The_SubBytes_step">Wikipedia</a> is a good resource too.</p>

<h3 id="subbytes">SubBytes</h3>

<p>This involved splitting the input into bytes and passing each through a Substitution Box (S-box). Unlike the DES, the AES uses the same S-box for all bytes.</p>

<p>Each byte from the input is replaced by a SubByte using an 8-bit substitution box (essentially a lookup table). Because we are dealing with a 128-bit block size, so each cell in the table is a byte (128/16 = 8).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a4/AES-SubBytes.svg" style="width:320px;height:166px" class="center" /></p>

<h3 id="shiftrows">ShiftRows</h3>

<p>Here, each row of the 128-bit internal state (input of <code class="language-plaintext highlighter-rouge">ShiftRows</code> which is output of <code class="language-plaintext highlighter-rouge">SubBytes</code>) of the cipher is shifted by a certain offset. In AES the top row is not shifted at all, the next row is shifted by 1 and 2 then 3 for the next two rows. This results in each column of the output state composed of bytes from each column of the input state.</p>

<blockquote>
  <p>This is important to avoid the columns being encrypted independently, because that would make AES into 4 independent block ciphers.</p>
</blockquote>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/66/AES-ShiftRows.svg" style="width:320px;height:119px;" class="center" /></p>

<h3 id="mixcolumns">MixColumns</h3>

<p>Here the output matrix of the <code class="language-plaintext highlighter-rouge">ShiftRows</code> step is pre-multiplied with a fixed matrix ‚Äì this helps with diffusion because if you change a<sub>0,1</sub> (even by 1-bit) the entire output column will change (as you know from matrix multiplication).</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/7/76/AES-MixColumns.svg" style="width:320px;height:170px;" class="center" /></p>

<h3 id="addroundkey">AddRoundKey</h3>

<p>The only operation in AES that directly operates on the AES round key. In this operation, the input to the round is <strong>XORed</strong> with the round key.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/ad/AES-AddRoundKey.svg" style="width:309px;height:240px;" class="center" /></p>

<h2 id="aes-is-secure">AES is secure</h2>

<p>A computer that can break DES in 8 seconds will take 1.3 √ó¬†10<sup>15</sup> years to break AES-128.</p>

<p>AES-256 can also provides post-quantum computing assurance.</p>

<h1 id="public-key-cryptography">Public Key Cryptography</h1>
       
        <h2 id="modular-arithmetic">Modular Arithmetic</h2>

<ol>
  <li>(A+B) mod n = ((A mod n) + B) mod n</li>
  <li>(A+B) mod n = ((A mod n) + (B mod n)) mod n</li>
  <li>(A*B) mod n = ((A mod n) * B) mod n</li>
  <li>(A*B) mod n = ((A mod n) * (B mod n)) mod n</li>
  <li>x<sup>A*B</sup> mod n = (x<sup>A</sup> mod n)<sup>B</sup> mod n</li>
  <li>(x<sup>A</sup> mod n)<sup>B</sup> mod n = (x<sup>B</sup> mod n)<sup>A</sup> mod n</li>
</ol>

<h2 id="the-primitive-root">The Primitive Root</h2>

<p><em>k = y <sup>x</sup></em> mod p</p>

<p><em>y</em> is the <strong>primitive root mod p</strong> if</p>

<ol>
  <li>Successive powers of <em>y</em> that takes mod p will generate results of 1 to p ‚àí¬†1.</li>
  <li>The generated numbers (<em>k</em>) are distributed uniformly in the range of [1, p ‚àí 1].</li>
</ol>

<blockquote>
  <p>If we pick a value of <strong><em>x</em></strong>, the value of <strong><em>k</em></strong> is equally likely to be any number in [1, p ‚àí 1].</p>
</blockquote>

<p>The above function is an example of a one-way function if</p>

<ul>
  <li><em>y</em> is the <strong>primitive root mod p</strong></li>
  <li><em>p</em> is an enormous number (e.g. 512-bits).</li>
</ul>

<p>This is because if we try a value of <em>x</em> for a given <em>k</em>, the probability that <em>x</em> is <strong>correct</strong> is <strong><em>1/(p-1)</em></strong>.</p>

<h2 id="public-key-encryption">Public Key Encryption</h2>

<blockquote>
  <p>The problem with secret key encryption is that it takes a lot of <strong>effort</strong> to transfer the key safely. There are a few ways:</p>

  <ul>
    <li>Physical Transfer</li>
    <li>Key Distribution Centre</li>
    <li>Online transfer by breaking the key up to ensure security.</li>
  </ul>
</blockquote>

<p>However, public key encryption provides a more <strong>elegant</strong> solution using a <strong>one-way function</strong> like the one <a href="#the-primitive-root">above</a>.</p>

<p>The idea is that each communication party generates a pair of keys, one private and one public ‚Äì KP<sub>a</sub> and KU<sub>a</sub> respectively where <em>a</em> represents one specific party/individual.</p>

<ul>
  <li>Sender of a message uses receiver‚Äôs public key to encrypt</li>
  <li>Receiver uses their own private key to decrypt.</li>
</ul>

<h2 id="rsa-encryption">RSA Encryption</h2>

<p><em>RSA is a type of public key encryption scheme. One of the oldest.</em></p>

<p><strong>To generate a public key.</strong></p>

<ul>
  <li>Choose 2 large secret prime numbers, p and q, and calculate <strong><em>n</em></strong> = p √ó q. <strong><em>n</em></strong> will be the <strong>public key</strong>.</li>
  <li>Select another value <strong><em>e</em></strong>, that is
    <ul>
      <li>relatively prime to <strong><em>p‚Äì1</em></strong>, <strong><em>q‚Äì1</em></strong>, and <strong><em>(p‚Äì1) √ó¬†(q-1)</em></strong>.</li>
      <li><strong><em>1 &lt; e &lt; (p‚Äì1)(q‚Äì1)</em></strong></li>
    </ul>
  </li>
</ul>

<p><strong>To encrypt a message.</strong> <strong><em>C = M<sup>e</sup></em> mod n</strong>, where <strong><em>C</em></strong> is the ciphertext, <strong><em>M</em></strong> is the message.</p>

<blockquote>
  <p>If an eavesdropper gets <strong><em>C</em></strong>, it is <strong>computationally infeasible</strong> to calculate <strong><em>M</em></strong>.</p>
</blockquote>

<p><strong>To generate a private key.</strong></p>

<ul>
  <li>We find a number <strong><em>d</em></strong> such that, <strong><em>e √ó¬†d = 1 mod ((p ‚Äì 1)(q ‚Äì 1))</em></strong></li>
  <li><strong><em>d</em></strong> is the private key owned by Alice and is called the multiplicative inverse of <strong><em>e mod (p‚Äì1)(q‚Äì1)</em></strong>.</li>
</ul>

<p><strong>To decrypt the ciphertext.</strong> <strong><em>M = C<sup>d</sup></em> mod n</strong>. Very easy to decrypt given the private key.</p>

<p>All receivers have to do is to keep the private key <strong>safe.</strong></p>

<h3 id="finding-the-private-key">Finding the private key</h3>

<p>There is a formal method of finding the <a href="https://people.csail.mit.edu/rivest/Rsapaper.pdf">private key</a> (it‚Äôs a 15 page paper).</p>

<p>Another way is by iteration. The goal is to find a multiple of <strong><em>e</em></strong>, which is 1 greater than some multiple of <strong><em>(p‚Äì1)(q‚Äì1)</em></strong>. So iterate through the multiples of <strong><em>(p‚Äì1)(q‚Äì1)</em></strong> and add 1, if that value is a multiple of <strong><em>e</em></strong> you have found a <strong><em>d</em></strong>, otherwise continue to the next multiple.</p>

<h3 id="why-is-rsa-secure">Why is RSA secure?</h3>

<p>To break RSA an attacker must</p>

<ul>
  <li>Either reverse the one-way function which is computationally difficult</li>
  <li>Or know <strong><em>d</em></strong>, which means to know <strong><em>p and q</em></strong> which means to know <strong><em>n</em></strong> ‚Äì but n = p √ó q is also a one-way function.</li>
  <li>The only way is brute force ‚Äì but a large enough key size will make this infeasible.</li>
</ul>

<blockquote>
  <p>To match the security of a 256-bit secret key, the RSA key needs 15460-bits. RSA started with 512-bit public key, but now it is 2048-bits and will need to increase again to 3072-bits from 2030 onwards.</p>
</blockquote>

<p>Another implication of a longer key length, k, is encryption and decryption time increases as well</p>

<ul>
  <li>Encryption time = O(k<sup>2</sup>)</li>
  <li>Decryption time = O(k<sup>3</sup>)</li>
</ul>

<h2 id="public-key-vs-secret-key-encryption">Public key vs Secret key Encryption</h2>

<blockquote>
  <p>DES is between 1000 and 10000 times faster than RSA (encryption &amp; decryption)</p>
</blockquote>

<table>
  <thead>
    <tr>
      <th>Secret</th>
      <th>Public</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Uses XOR, substitution, permutation ‚Äì <strong>fast</strong></td>
      <td>Uses a one-way function ‚Äì <strong>slower</strong></td>
    </tr>
    <tr>
      <td>Key is secret ‚Äì requires shorter key for <strong>same</strong> level of security<br />Also means its, again, <strong>faster</strong>.</td>
      <td>Only relies on the length of public key to prevent the crack with brute force<br />Long key ‚Äì&gt; <strong>slower</strong></td>
    </tr>
  </tbody>
</table>


                
                <footer class="site-footer">
                    
                    <span class="site-footer-owner"><a href="https://github.com/CSRG-Group/dcs-notes.github.io">dcs-notes.github.io</a> is maintained by <a href="https://github.com/CSRG-Group">CSRG-Group</a>.</span>
                    
                    <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub
                            Pages</a>.</span>
                </footer>
            </main>
        </div>
    </div>
</body>

</html>